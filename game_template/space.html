<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>동물들의 대탈주</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body, button, h1, p, div, input {
            font-family: 'Jua', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            background-color: #A7F3D0;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path d="M 10 10 C 20 20, 40 20, 50 10 S 70 0, 80 10 S 100 20, 100 20" stroke="%2368D391" fill="none" stroke-width="2"/><path d="M 0 50 C 10 40, 30 40, 40 50 S 60 60, 70 50 S 90 40, 100 50" stroke="%2368D391" fill="none" stroke-width="2"/></svg>');
            background-size: 100px 100px;
        }
        .progress-bar-container { width: 80%; height: 20px; background-color: rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden; border: 2px solid white; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #68D391, #F6E05E); transition: width 0.1s linear; }
        #joystick-container { position: absolute; bottom: 30px; right: 30px; width: 120px; height: 120px; background: rgba(0, 0, 0, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; display: flex; align-items: center; justify-content: center; }
        #joystick-handle { width: 60px; height: 60px; background: rgba(255, 255, 255, 0.4); border-radius: 50%; position: absolute; transition: transform 0.1s; }
    </style>
</head>
<body class="bg-gray-800 text-white flex items-center justify-center min-h-screen m-0 p-0 overflow-hidden">

    <div id="game-container" class="relative w-full h-full max-w-lg aspect-[9/16] bg-black shadow-2xl">
        <canvas id="gameCanvas"></canvas>

        <div id="in-game-ui" class="absolute top-0 left-0 w-full p-4 hidden">
            <div class="flex justify-between items-center text-black">
                <div id="lives-ui" class="text-2xl bg-white/50 px-3 py-1 rounded-lg">❤️ <span id="lives">3</span></div>
                <div id="stage-name-ui" class="text-2xl bg-white/50 px-3 py-1 rounded-lg"><span id="stage-name"></span></div>
                <div id="survival-time-ui" class="text-2xl bg-white/50 px-3 py-1 rounded-lg hidden">시간: <span id="survival-time">0</span>s</div>
            </div>
            <div id="progress-bar-wrapper" class="progress-bar-container mx-auto mt-2">
                <div id="time-progress" class="progress-bar" style="width: 100%;"></div>
            </div>
        </div>

        <div id="overlay" class="absolute inset-0 bg-black bg-opacity-60 flex flex-col items-center justify-center text-center p-4 z-10">
            <h1 id="title" class="text-6xl font-extrabold text-yellow-300 mb-4">동물들의 대탈주</h1>
            <p id="subtitle" class="text-xl mb-8">사육사가 되어 동물들을 피하세요!</p>
            <div id="main-menu-buttons" class="flex flex-col space-y-4">
                <div class="flex space-x-4">
                    <button id="storyModeButton" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 rounded-full text-2xl font-bold shadow-lg">스토리</button>
                    <button id="infiniteModeButton" class="px-8 py-4 bg-purple-600 hover:bg-purple-700 rounded-full text-2xl font-bold shadow-lg">무한모드</button>
                </div>
                <button id="rankingButton" class="px-10 py-3 bg-yellow-600 hover:bg-yellow-700 rounded-full text-xl font-bold shadow-lg">랭킹 보기</button>
                <button id="helpButton" class="px-10 py-3 bg-gray-600 hover:bg-gray-700 rounded-full text-xl font-bold shadow-lg">게임 설명</button>
            </div>
            <div id="end-game-buttons" class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 hidden mt-4">
                 <button id="retryButton" class="px-10 py-4 bg-green-600 hover:bg-green-700 rounded-full text-2xl font-bold shadow-lg">스테이지 재시도</button>
                 <button id="restartButton" class="px-10 py-4 bg-blue-600 hover:bg-blue-700 rounded-full text-2xl font-bold shadow-lg">처음부터</button>
            </div>
        </div>
        
        <div id="nickname-overlay" class="absolute inset-0 bg-black bg-opacity-80 flex-col items-center justify-center text-center p-6 z-30 hidden">
            <h2 class="text-4xl font-bold text-yellow-300 mb-6">닉네임을 입력하세요</h2>
            <input type="text" id="nicknameInput" class="text-black text-2xl text-center p-2 rounded-lg" maxlength="10" placeholder="10자 이내">
            <button id="confirmNicknameButton" class="mt-8 px-10 py-3 bg-blue-500 hover:bg-blue-600 rounded-full text-xl font-bold shadow-lg">확인</button>
        </div>

        <div id="character-select-overlay" class="absolute inset-0 bg-black bg-opacity-80 flex-col items-center justify-center text-center p-6 z-20 hidden">
            <h2 class="text-4xl font-bold text-yellow-300 mb-6">사육사 선택</h2>
            <div id="character-grid" class="grid grid-cols-3 gap-4"></div>
            <button id="backToMainButton" class="mt-8 px-10 py-3 bg-gray-500 hover:bg-gray-600 rounded-full text-xl font-bold shadow-lg">뒤로 가기</button>
        </div>

        <div id="ranking-overlay" class="absolute inset-0 bg-black bg-opacity-90 flex-col items-center p-6 z-20 hidden text-center">
            <h2 class="text-4xl font-bold text-yellow-300 mb-4">명예의 전당</h2>
            <div class="flex border-b-2 border-yellow-300 w-full max-w-sm mb-4">
                <button id="storyRankTab" class="flex-1 py-2 text-xl border-b-4 border-yellow-500 text-yellow-400">스토리 모드</button>
                <button id="infiniteRankTab" class="flex-1 py-2 text-xl border-b-4 border-transparent">무한 모드</button>
            </div>
            <div id="ranking-list" class="w-full max-w-sm text-lg space-y-2 overflow-y-auto"></div>
            <button id="closeRankingButton" class="mt-8 px-10 py-3 bg-red-500 hover:bg-red-600 rounded-full text-xl font-bold shadow-lg">닫기</button>
        </div>

        <div id="help-overlay" class="absolute inset-0 bg-black bg-opacity-80 flex-col items-center justify-center text-center p-6 z-20 hidden">
            <h2 class="text-4xl font-bold text-yellow-300 mb-6">게임 설명</h2>
            <div class="text-left max-w-sm space-y-3 text-lg">
                <p>🧑‍🌾 <span class="font-bold">목표:</span> 탈출한 동물들을 피하며 각 구역에서 살아남으세요!</p>
                <p>🕹️ <span class="font-bold">조작:</span> 조이스틱으로 사육사를 조종합니다.</p>
                <p class="font-bold text-yellow-400 mt-4">아이템</p>
                <p>🥅 <span class="font-bold">튼튼한 그물:</span> 5초간 충돌을 1회 막아줍니다.</p>
                <p>💉 <span class="font-bold">마취총:</span> 화면의 모든 동물을 잠재웁니다.</p>
                <p>🚙 <span class="font-bold">지프차:</span> 안전한 곳으로 즉시 이동합니다.</p>
                <p>🍖 <span class="font-bold">먹이:</span> 5초간 모든 동물이 느려집니다.</p>
            </div>
            <button id="closeHelpButton" class="mt-8 px-10 py-3 bg-red-500 hover:bg-red-600 rounded-full text-xl font-bold shadow-lg">닫기</button>
        </div>
        
        <div id="joystick-container" class="hidden">
            <div id="joystick-handle"></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        let db, auth, userId, userNickname;
        let animationFrameId;
        let player, animals, particles, lives, gameOver, currentStageIndex, items;
        let stageTimer, stageDuration, lastTime, globalSpeedModifier, survivalTime;
        let joystickInput = { x: 0, y: 0 };
        const CHARACTERS = ['🧑‍🌾', '👩‍🌾', '👨‍🌾', '👮', '🚜'];
        let selectedCharacter = CHARACTERS[0];
        let currentGameMode = null;
        gameOver = true;
        
        const isRankingEnabled = new URLSearchParams(window.location.search).get('rank_on') === '1';
        const isNicknameEnabled = new URLSearchParams(window.location.search).get('nickname_on') === '1';

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const storyModeButton = document.getElementById('storyModeButton');
        const infiniteModeButton = document.getElementById('infiniteModeButton');
        const retryButton = document.getElementById('retryButton');
        const restartButton = document.getElementById('restartButton');
        const helpButton = document.getElementById('helpButton');
        const helpOverlay = document.getElementById('help-overlay');
        const closeHelpButton = document.getElementById('closeHelpButton');
        const characterSelectOverlay = document.getElementById('character-select-overlay');
        const characterGrid = document.getElementById('character-grid');
        const backToMainButton = document.getElementById('backToMainButton');
        const titleEl = document.getElementById('title');
        const subtitleEl = document.getElementById('subtitle');
        const inGameUI = document.getElementById('in-game-ui');
        const livesUI = document.getElementById('lives-ui');
        const livesEl = document.getElementById('lives');
        const stageNameUI = document.getElementById('stage-name-ui');
        const stageNameEl = document.getElementById('stage-name');
        const survivalTimeUI = document.getElementById('survival-time-ui');
        const survivalTimeEl = document.getElementById('survival-time');
        const progressBarWrapper = document.getElementById('progress-bar-wrapper');
        const timeProgressEl = document.getElementById('time-progress');
        const joystickContainer = document.getElementById('joystick-container');
        const joystickHandle = document.getElementById('joystick-handle');
        const endGameButtons = document.getElementById('end-game-buttons');
        const nicknameOverlay = document.getElementById('nickname-overlay');
        const nicknameInput = document.getElementById('nicknameInput');
        const confirmNicknameButton = document.getElementById('confirmNicknameButton');
        const rankingButton = document.getElementById('rankingButton');
        const rankingOverlay = document.getElementById('ranking-overlay');
        const closeRankingButton = document.getElementById('closeRankingButton');
        const storyRankTab = document.getElementById('storyRankTab');
        const infiniteRankTab = document.getElementById('infiniteRankTab');
        const rankingList = document.getElementById('ranking-list');
        
        const STAGES = [
            { name: "1. 농장", duration: 20, spawnRate: 500, minSpeed: 1, maxSpeed: 2, animals: ['🐔', '🐷', '🐮', '🐑'] },
            { name: "2. 초원", duration: 20, spawnRate: 450, minSpeed: 1.2, maxSpeed: 2.5, animals: ['🦓', '🦒', '🐘', '🦏'] },
            { name: "3. 정글", duration: 25, spawnRate: 400, minSpeed: 1.5, maxSpeed: 3, animals: ['🐒', '🐍', '🐅', '🦍'] },
            { name: "4. 극지방", duration: 25, spawnRate: 380, minSpeed: 1.8, maxSpeed: 3.5, animals: ['🐧', '🐻‍❄️', '🦊', '🦭'] },
            { name: "5. 바다", duration: 30, spawnRate: 350, minSpeed: 2.0, maxSpeed: 4.0, animals: ['🐙', '🐡', '🦀', '🐬'] },
        ];
        const ALL_ANIMALS = [...new Set(STAGES.flatMap(s => s.animals))];

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        async function setupFirebase() {
            try {
                const firebaseConfig = {
                  apiKey: "AIzaSyCOinJqnLyonSS3nrYgauBmBOWGB1fdrHI",
                  authDomain: "gamestudio1-3af17.firebaseapp.com",
                  databaseURL: "https://gamestudio1-3af17-default-rtdb.asia-southeast1.firebasedatabase.app",
                  projectId: "gamestudio1-3af17",
                  storageBucket: "gamestudio1-3af17.appspot.com",
                  messagingSenderId: "515670984841",
                  appId: "1:515670984841:web:d6bc6b19e101bd931bde58",
                  measurementId: "G-ECV6KSXEJK"
                };
                
                if (!firebaseConfig.apiKey) {
                    throw new Error("Firebase config is empty.");
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, user => {
                    if (user) {
                        userId = user.uid;
                        checkNickname();
                    } else {
                        signInAnonymously(auth).catch(error => {
                            console.error("Anonymous sign-in failed:", error);
                            if (error.code === 'auth/configuration-not-found') {
                                console.warn("Firebase 랭킹 기능을 사용할 수 없습니다. Firebase 콘솔 > Authentication > Sign-in method에서 '익명' 로그인을 활성화해주세요.");
                                disableRankingFeatures();
                            }
                            checkNickname();
                        });
                    }
                });
            } catch (e) {
                console.error("Firebase initialization failed.", e);
                disableRankingFeatures();
                checkNickname();
            }
        }

        function disableRankingFeatures() {
            rankingButton.textContent = "랭킹 (비활성화)";
            rankingButton.disabled = true;
            rankingButton.classList.add("opacity-50", "cursor-not-allowed");
        }

        function checkNickname() {
            if (!isRankingEnabled) return;
            userNickname = localStorage.getItem('userNickname');
            if (isNicknameEnabled && !userNickname) {
                nicknameOverlay.classList.remove('hidden');
                nicknameOverlay.classList.add('flex');
            }
        }

        async function saveScore(mode, scoreValue) {
            if (!isRankingEnabled || !db || !userId || !userNickname) return;
            
            const scoreRef = doc(db, `scores/${userId}`);
            const docSnap = await getDoc(scoreRef);
            
            let dataToSave = { userId, nickname: userNickname };
            let newHighScore = false;

            if (mode === 'story') {
                const currentBest = docSnap.exists() ? docSnap.data().storyModeScore || 0 : 0;
                if (scoreValue > currentBest) {
                    dataToSave.storyModeScore = scoreValue;
                    newHighScore = true;
                }
            } else {
                const currentBest = docSnap.exists() ? docSnap.data().infiniteModeScore || 0 : 0;
                if (scoreValue > currentBest) {
                    dataToSave.infiniteModeScore = scoreValue;
                    newHighScore = true;
                }
            }

            if (newHighScore) {
                await setDoc(scoreRef, dataToSave, { merge: true });
            }
        }

        async function showRanking(mode) {
            if (!db) {
                rankingList.innerHTML = '<p>랭킹을 불러올 수 없습니다.</p>';
                return;
            }
            rankingList.innerHTML = '<p>로딩 중...</p>';
            
            const field = mode === 'story' ? 'storyModeScore' : 'infiniteModeScore';
            const q = query(collection(db, "scores"), orderBy(field, "desc"), limit(10));
            
            try {
                const querySnapshot = await getDocs(q);
                let rankHtml = '';
                let rank = 1;
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const score = mode === 'story' ? `${data.storyModeScore || 0} 스테이지` : `${(data.infiniteModeScore || 0).toFixed(1)}초`;
                    rankHtml += `<div class="flex justify-between p-2 ${rank % 2 === 0 ? 'bg-gray-700' : ''} rounded">
                                    <span>${rank}. ${data.nickname}</span>
                                    <span>${score}</span>
                                 </div>`;
                    rank++;
                });

                if (rankHtml === '') {
                    rankHtml = '<p>아직 랭킹이 없습니다.</p>';
                }
                rankingList.innerHTML = rankHtml;
            } catch(e) {
                console.error("Error fetching ranking:", e);
                rankingList.innerHTML = '<p>랭킹을 불러오는 데 실패했습니다. Firestore 규칙을 확인하세요.</p>';
            }
        }

        class Player {
            constructor(x, y) {
                this.x = x; this.y = y; this.emoji = selectedCharacter; this.size = 40;
                this.angle = -Math.PI / 2; this.speed = 4; this.shielded = false;
            }
            draw() {
                if (this.shielded) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.4)';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(59, 130, 246, 1)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.font = `${this.size}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
            }
            update() {
                this.x += joystickInput.x * this.speed;
                this.y += joystickInput.y * this.speed;

                if (this.x - this.size/2 < 0) this.x = this.size/2;
                if (this.x + this.size/2 > canvas.width) this.x = canvas.width - this.size/2;
                if (this.y - this.size/2 < 0) this.y = this.size/2;
                if (this.y + this.size/2 > canvas.height) this.y = canvas.height - this.size/2;

                if (joystickInput.x !== 0 || joystickInput.y !== 0) {
                    this.angle = Math.atan2(joystickInput.y, joystickInput.x) + Math.PI / 2;
                }
                this.draw();
            }
        }

        class Animal {
            constructor(x, y, emoji, velocity) {
                this.x = x; this.y = y; this.emoji = emoji;
                this.size = 25 + Math.random() * 25;
                this.velocity = velocity;
            }
            draw() {
                ctx.font = `${this.size}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
            }
            update() {
                this.x += this.velocity.x * globalSpeedModifier;
                this.y += this.velocity.y * globalSpeedModifier;
                this.draw();
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x; this.y = y; this.size = Math.random() * 5 + 2;
                this.color = `hsl(${Math.random() * 60 + 100}, 100%, 70%)`;
                this.velocity = { x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4 };
                this.alpha = 1;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= 0.02;
                this.draw();
            }
        }
        
        class Item {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.emoji = type === 'shield' ? '🥅' : (type === 'bomb' ? '💉' : (type === 'teleport' ? '🚙' : '🍖'));
                this.size = 30;
            }
            draw() {
                ctx.font = `${this.size}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
            }
            update() { this.draw(); }
        }

        function initGame() {
            lives = 3;
            gameOver = false;
            if (currentGameMode === 'story') {
                currentStageIndex = 0;
                setupStage();
            } else {
                setupInfiniteMode();
            }
        }

        function retryCurrentStage() {
            lives = 3;
            gameOver = false;
            setupStage();
        }

        function setupStage() {
            const stage = STAGES[currentStageIndex];
            player = new Player(canvas.width / 2, canvas.height - 80);
            animals = []; particles = []; items = [];
            stageDuration = stage.duration * 1000;
            stageTimer = stageDuration;
            lastTime = undefined;
            globalSpeedModifier = 1;
            
            stageNameUI.classList.remove('hidden');
            livesUI.classList.remove('hidden');
            progressBarWrapper.classList.remove('hidden');
            survivalTimeUI.classList.add('hidden');
            stageNameEl.textContent = stage.name;
            livesEl.textContent = lives;
            inGameUI.classList.remove('hidden');
            joystickContainer.classList.remove('hidden');
            overlay.classList.add('hidden');
            characterSelectOverlay.classList.add('hidden');

            startSpawning();
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(animate);
        }
        
        function setupInfiniteMode() {
            player = new Player(canvas.width / 2, canvas.height - 80);
            animals = []; particles = []; items = [];
            lastTime = undefined;
            globalSpeedModifier = 1;
            survivalTime = 0;
            
            livesEl.textContent = lives;
            stageNameUI.classList.add('hidden');
            progressBarWrapper.classList.add('hidden');
            survivalTimeUI.classList.remove('hidden');
            livesUI.classList.remove('hidden');
            inGameUI.classList.remove('hidden');
            joystickContainer.classList.remove('hidden');
            overlay.classList.add('hidden');
            characterSelectOverlay.classList.add('hidden');

            startSpawning();

            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(animate);
        }

        let spawnInterval, itemInterval;
        function startSpawning() {
            clearInterval(spawnInterval);
            clearInterval(itemInterval);
            if (currentGameMode === 'story') {
                const stage = STAGES[currentStageIndex];
                spawnInterval = setInterval(spawnAnimal, stage.spawnRate);
            } else { // Infinite Mode
                spawnInterval = setInterval(spawnAnimal, 500); // Start with a base rate
            }
            itemInterval = setInterval(spawnItem, 8000);
        }

        function spawnAnimal() {
            if (gameOver || !player) return;
            
            let emoji, speedMultiplier = 1;

            if (currentGameMode === 'story') {
                const stage = STAGES[currentStageIndex];
                emoji = stage.animals[Math.floor(Math.random() * stage.animals.length)];
            } else { // Infinite Mode
                const animalIndex = Math.min(ALL_ANIMALS.length - 1, Math.floor(survivalTime / 10));
                emoji = ALL_ANIMALS[Math.floor(Math.random() * (animalIndex + 1))];
                speedMultiplier = 1 + (survivalTime / 60);
            }

            let x, y;
            const edge = Math.floor(Math.random() * 4);
            if (edge === 0) { x = Math.random() * canvas.width; y = -30; }
            else if (edge === 1) { x = canvas.width + 30; y = Math.random() * canvas.height; }
            else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 30; }
            else { x = -30; y = Math.random() * canvas.height; }

            const targetX = player.x + (Math.random() - 0.5) * 100;
            const targetY = player.y + (Math.random() - 0.5) * 100;
            const angle = Math.atan2(targetY - y, targetX - x);
            const speed = (Math.random() * 1.5 + 1) * speedMultiplier;
            const velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
            animals.push(new Animal(x, y, emoji, velocity));
        }

        function spawnItem() {
            if (gameOver) return;
            const itemTypes = ['shield', 'bomb', 'teleport', 'slowmo'];
            const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
            const x = Math.random() * (canvas.width - 60) + 30;
            const y = Math.random() * (canvas.height - 100) + 50;
            items.push(new Item(x, y, type));
        }

        function animate(currentTime) {
            if (gameOver) return;
            animationFrameId = requestAnimationFrame(animate);
            
            if (lastTime === undefined) lastTime = currentTime;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            player.update();
            particles.forEach((p, i) => p.alpha <= 0 ? particles.splice(i, 1) : p.update());
            items.forEach((item, i) => {
                item.update();
                const dist = Math.hypot(player.x - item.x, player.y - item.y);
                if (dist < player.size / 2 + item.size / 2) {
                    activateItem(item.type);
                    items.splice(i, 1);
                }
            });

            animals.forEach((a, i) => {
                a.update();
                const dist = Math.hypot(player.x - a.x, player.y - a.y);
                if (dist < player.size / 2 + a.size / 2) {
                    handleCollision(i);
                }
            });

            if (currentGameMode === 'story') {
                stageTimer -= deltaTime;
                timeProgressEl.style.width = `${Math.max(0, stageTimer / stageDuration) * 100}%`;
                if (stageTimer <= 0) stageClear();
            } else {
                survivalTime += deltaTime / 1000;
                survivalTimeEl.textContent = survivalTime.toFixed(1);
            }
        }

        function activateItem(type) {
            if (type === 'shield') {
                player.shielded = true;
                setTimeout(() => { player.shielded = false; }, 5000);
            } else if (type === 'bomb') {
                animals.forEach(a => {
                     for (let i = 0; i < 10; i++) particles.push(new Particle(a.x, a.y));
                });
                animals = [];
            } else if (type === 'teleport') {
                player.x = Math.random() * (canvas.width - 100) + 50;
                player.y = Math.random() * (canvas.height - 100) + 50;
                for (let i = 0; i < 30; i++) particles.push(new Particle(player.x, player.y));
            } else if (type === 'slowmo') {
                globalSpeedModifier = 0.5;
                setTimeout(() => { globalSpeedModifier = 1; }, 5000);
            }
        }
        function handleCollision(index) {
            if (player.shielded) {
                player.shielded = false;
                animals.splice(index, 1);
                return;
            }
            for (let i = 0; i < 20; i++) particles.push(new Particle(player.x, player.y));
            animals.splice(index, 1);
            lives--;
            livesEl.textContent = lives;
            if (lives <= 0) {
                endGame("게임 오버!");
            }
        }
        function stageClear() {
            clearInterval(spawnInterval);
            clearInterval(itemInterval);
            currentStageIndex++;
            if (currentStageIndex >= STAGES.length) {
                endGame("모든 동물원에서 살아남았습니다!");
                saveScore('story', currentStageIndex);
            } else {
                titleEl.textContent = "구역 클리어!";
                subtitleEl.textContent = `다음: ${STAGES[currentStageIndex].name}`;
                startButton.textContent = "다음 구역으로";
                overlay.classList.remove('hidden');
                inGameUI.classList.add('hidden');
                joystickContainer.classList.add('hidden');
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        function endGame(message) {
            gameOver = true;
            clearInterval(spawnInterval);
            clearInterval(itemInterval);
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            
            titleEl.textContent = message;
            
            if (currentGameMode === 'story') {
                saveScore('story', currentStageIndex);
                let finalStageName = STAGES[currentStageIndex] ? STAGES[currentStageIndex].name : STAGES[STAGES.length - 1].name;
                subtitleEl.textContent = `최종 생존 구역: ${finalStageName}`;
                if (message !== "모든 동물원에서 살아남았습니다!") {
                    retryButton.classList.remove('hidden');
                } else {
                    retryButton.classList.add('hidden');
                }
            } else { // Infinite Mode
                saveScore('infinite', survivalTime);
                subtitleEl.textContent = `최종 생존 시간: ${survivalTime.toFixed(1)}초`;
                retryButton.classList.add('hidden');
            }
            
            overlay.classList.remove('hidden');
            inGameUI.classList.add('hidden');
            joystickContainer.classList.add('hidden');
            endGameButtons.classList.remove('hidden');
            storyModeButton.classList.add('hidden');
            infiniteModeButton.classList.add('hidden');
            helpButton.classList.add('hidden');
        }

        function showMainMenu() {
            titleEl.textContent = "동물들의 대탈주";
            subtitleEl.textContent = "사육사가 되어 동물들을 피하세요!";
            overlay.classList.remove('hidden');
            characterSelectOverlay.classList.add('hidden');
            endGameButtons.classList.add('hidden');
            storyModeButton.classList.remove('hidden');
            infiniteModeButton.classList.remove('hidden');
            helpButton.classList.remove('hidden');
        }

        function populateCharacterSelect() {
            characterGrid.innerHTML = '';
            CHARACTERS.forEach(char => {
                const charButton = document.createElement('button');
                charButton.className = 'text-6xl p-4 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors';
                charButton.textContent = char;
                charButton.onclick = () => {
                    selectedCharacter = char;
                    initGame();
                };
                characterGrid.appendChild(charButton);
            });
        }

        function showCharacterSelect(mode) {
            if (isRankingEnabled && !userNickname) {
                nicknameOverlay.classList.remove('hidden');
                nicknameOverlay.classList.add('flex');
                return;
            }
            currentGameMode = mode;
            overlay.classList.add('hidden');
            characterSelectOverlay.classList.remove('hidden');
            characterSelectOverlay.classList.add('flex');
        }

        storyModeButton.addEventListener('click', () => showCharacterSelect('story'));
        infiniteModeButton.addEventListener('click', () => showCharacterSelect('infinite'));
        retryButton.addEventListener('click', () => retryCurrentStage());
        restartButton.addEventListener('click', () => showMainMenu());
        helpButton.addEventListener('click', () => { helpOverlay.classList.remove('hidden'); helpOverlay.classList.add('flex'); });
        closeHelpButton.addEventListener('click', () => { helpOverlay.classList.add('hidden'); helpOverlay.classList.remove('flex'); });
        backToMainButton.addEventListener('click', () => showMainMenu());
        rankingButton.addEventListener('click', () => {
            rankingOverlay.classList.remove('hidden');
            rankingOverlay.classList.add('flex');
            showRanking('story');
        });
        closeRankingButton.addEventListener('click', () => {
            rankingOverlay.classList.add('hidden');
            rankingOverlay.classList.remove('flex');
        });
        storyRankTab.addEventListener('click', () => {
            storyRankTab.classList.add('border-yellow-500', 'text-yellow-400');
            infiniteRankTab.classList.remove('border-yellow-500', 'text-yellow-400');
            showRanking('story');
        });
        infiniteRankTab.addEventListener('click', () => {
            infiniteRankTab.classList.add('border-yellow-500', 'text-yellow-400');
            storyRankTab.classList.remove('border-yellow-500', 'text-yellow-400');
            showRanking('infinite');
        });
        
        let joystickActive = false;
        function handleJoystick(e) {
            e.preventDefault();
            if (!joystickActive) return;
            const rect = joystickContainer.getBoundingClientRect();
            const touch = e.touches[0];
            let x = (touch.clientX - rect.left - rect.width / 2);
            let y = (touch.clientY - rect.top - rect.height / 2);
            
            const mag = Math.sqrt(x*x + y*y);
            if (mag > rect.width / 4) {
                x = (x / mag) * (rect.width / 4);
                y = (y / mag) * (rect.width / 4);
            }
            
            joystickHandle.style.transform = `translate(${x}px, ${y}px)`;
            
            joystickInput = { x: x / (rect.width / 4), y: y / (rect.width / 4) };
        }
        
        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
        }, { passive: false });

        joystickContainer.addEventListener('touchmove', handleJoystick, { passive: false });

        window.addEventListener('touchend', (e) => {
            joystickActive = false;
            joystickHandle.style.transform = 'translate(0, 0)';
            joystickInput = { x: 0, y: 0 };
        });
        
        confirmNicknameButton.addEventListener('click', () => {
            const nickname = nicknameInput.value.trim();
            if (nickname.length > 0 && nickname.length <= 10) {
                userNickname = nickname;
                localStorage.setItem('userNickname', nickname);
                nicknameOverlay.classList.add('hidden');
            } else {
                alert('닉네임은 1~10자 사이로 입력해주세요.');
            }
        });

        window.addEventListener('resize', resizeCanvas);
        
        document.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            populateCharacterSelect();
            if (isRankingEnabled) {
                setupFirebase();
            } else {
                rankingButton.style.display = 'none';
            }
        });
    </script>
</body>
</html>
