<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>소행성 피하기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body, button, h1, p, div {
            font-family: 'Jua', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            background-color: #0c0a18;
            background-image: 
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 40px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 30px),
                radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 40px),
                radial-gradient(rgba(255,255,255,.4), rgba(255,255,255,.1) 2px, transparent 30px);
            background-size: 550px 550px, 350px 350px, 250px 250px, 150px 150px; 
            background-position: 0 0, 40px 60px, 130px 270px, 70px 100px;
            animation: move-background 20s linear infinite;
        }
        @keyframes move-background {
            from { background-position: 0 0, 40px 60px, 130px 270px, 70px 100px; }
            to { background-position: -550px -550px, -310px -350px, -250px -540px, -150px -250px; }
        }
        .progress-bar-container {
            width: 80%;
            height: 20px;
            background-color: rgba(0,0,0,0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid white;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #F6E05E, #F56565);
            transition: width 0.1s linear;
        }
        /* 조이스틱 스타일 */
        #joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #joystick-handle {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: absolute;
            transition: transform 0.1s;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen m-0 p-0 overflow-hidden">

    <div id="game-container" class="relative w-full h-full max-w-lg aspect-[9/16] bg-black shadow-2xl">
        <canvas id="gameCanvas"></canvas>

        <!-- 인게임 UI -->
        <div id="in-game-ui" class="absolute top-0 left-0 w-full p-4 hidden">
            <div class="flex justify-between items-center">
                <div class="text-2xl">❤️ <span id="lives">3</span></div>
                <div class="text-2xl"><span id="stage-name"></span></div>
            </div>
            <div class="progress-bar-container mx-auto mt-2">
                <div id="time-progress" class="progress-bar" style="width: 100%;"></div>
            </div>
        </div>

        <!-- 오버레이 화면 -->
        <div id="overlay" class="absolute inset-0 bg-black bg-opacity-60 flex flex-col items-center justify-center text-center p-4 z-10">
            <h1 id="title" class="text-6xl font-extrabold text-yellow-300 mb-4">소행성 피하기</h1>
            <p id="subtitle" class="text-xl mb-8">조이스틱으로 우주선을 조종해 살아남으세요!</p>
            <button id="startButton" class="px-10 py-4 bg-blue-600 hover:bg-blue-700 rounded-full text-2xl font-bold shadow-lg">게임 시작</button>
        </div>
        
        <!-- 조이스틱 -->
        <div id="joystick-container" class="hidden">
            <div id="joystick-handle"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const startButton = document.getElementById('startButton');
        const titleEl = document.getElementById('title');
        const subtitleEl = document.getElementById('subtitle');
        const inGameUI = document.getElementById('in-game-ui');
        const livesEl = document.getElementById('lives');
        const stageNameEl = document.getElementById('stage-name');
        const timeProgressEl = document.getElementById('time-progress');
        const joystickContainer = document.getElementById('joystick-container');
        const joystickHandle = document.getElementById('joystick-handle');

        let animationFrameId;
        let player, asteroids, particles, lives, gameOver, currentStageIndex;
        let stageTimer, stageDuration, lastTime;
        let joystickInput = { x: 0, y: 0 };

        gameOver = true;

        const STAGES = [
            { name: "1. 과일 지대", duration: 15, spawnRate: 500, minSpeed: 1, maxSpeed: 2, asteroids: ['🍎', '🍊', '🍌'] },
            { name: "2. 채소 지대", duration: 15, spawnRate: 450, minSpeed: 1.2, maxSpeed: 2.5, asteroids: ['🥕', '🥦', '🍆'] },
            { name: "3. 디저트 지대", duration: 20, spawnRate: 400, minSpeed: 1.5, maxSpeed: 3, asteroids: ['🍩', '🍪', '🧁'] },
            { name: "4. 아침식사 영역", duration: 20, spawnRate: 400, minSpeed: 1.6, maxSpeed: 3.2, asteroids: ['🍳', '🥞', '�'] },
            { name: "5. 패스트푸드 성운", duration: 20, spawnRate: 380, minSpeed: 1.8, maxSpeed: 3.5, asteroids: ['🍔', '🍕', '🍟'] },
            { name: "6. 사탕 행성군", duration: 25, spawnRate: 350, minSpeed: 2.0, maxSpeed: 3.8, asteroids: ['🍭', '🍬', '🍫'] },
            { name: "7. 해산물 해역", duration: 25, spawnRate: 350, minSpeed: 2.2, maxSpeed: 4.0, asteroids: ['🦀', '🐙', '🐟'] },
            { name: "8. 동물 농장", duration: 25, spawnRate: 320, minSpeed: 2.4, maxSpeed: 4.2, asteroids: ['🐔', '🐷', '🐮'] },
            { name: "9. 야생동물 구역", duration: 25, spawnRate: 300, minSpeed: 2.5, maxSpeed: 4.5, asteroids: ['🦊', '🐻', '🐼'] },
            { name: "10. 벌레 떼", duration: 30, spawnRate: 280, minSpeed: 2.6, maxSpeed: 4.8, asteroids: ['🐞', '🦋', '🐛'] },
            { name: "11. 이상 기후", duration: 30, spawnRate: 280, minSpeed: 2.8, maxSpeed: 5.0, asteroids: ['☀️', '☁️', '⚡️'] },
            { name: "12. 스포츠 용품", duration: 30, spawnRate: 250, minSpeed: 3.0, maxSpeed: 5.2, asteroids: ['⚽️', '🏀', '🏈'] },
            { name: "13. 공구상자", duration: 30, spawnRate: 250, minSpeed: 3.2, maxSpeed: 5.5, asteroids: ['🔨', '🔧', '🔩'] },
            { name: "14. 핼러윈 파티", duration: 35, spawnRate: 220, minSpeed: 3.4, maxSpeed: 5.8, asteroids: ['👻', '🎃', '💀'] },
            { name: "15. 보물창고", duration: 35, spawnRate: 220, minSpeed: 3.5, maxSpeed: 6.0, asteroids: ['💰', '💎', '💵'] },
            { name: "16. 교통지옥", duration: 35, spawnRate: 200, minSpeed: 3.6, maxSpeed: 6.2, asteroids: ['🚗', '🚌', '🚲'] },
            { name: "17. 악기 연주회", duration: 35, spawnRate: 200, minSpeed: 3.8, maxSpeed: 6.5, asteroids: ['🎵', '🎸', '🥁'] },
            { name: "18. 겨울 왕국", duration: 40, spawnRate: 180, minSpeed: 4.0, maxSpeed: 6.8, asteroids: ['❄️', '⛄️', '🧊'] },
            { name: "19. 외계 침공", duration: 40, spawnRate: 150, minSpeed: 4.2, maxSpeed: 7.0, asteroids: ['👽', '🛸', '👾'] },
            { name: "20. 최종 혼돈", duration: 60, spawnRate: 100, minSpeed: 5.0, maxSpeed: 8.0, asteroids: ['🍎', '🍕', '💀', '👽', '💰'] }
        ];

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.emoji = '🚀';
                this.size = 40;
                this.angle = -Math.PI / 2;
                this.speed = 4;
            }
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.font = `${this.size}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
            }
            update() {
                this.x += joystickInput.x * this.speed;
                this.y += joystickInput.y * this.speed;

                if (this.x - this.size/2 < 0) this.x = this.size/2;
                if (this.x + this.size/2 > canvas.width) this.x = canvas.width - this.size/2;
                if (this.y - this.size/2 < 0) this.y = this.size/2;
                if (this.y + this.size/2 > canvas.height) this.y = canvas.height - this.size/2;

                if (joystickInput.x !== 0 || joystickInput.y !== 0) {
                    this.angle = Math.atan2(joystickInput.y, joystickInput.x) + Math.PI / 2;
                }
                this.draw();
            }
        }

        class Asteroid {
            constructor(x, y, emoji, velocity) {
                this.x = x;
                this.y = y;
                this.emoji = emoji;
                this.size = 20 + Math.random() * 20;
                this.velocity = velocity;
            }
            draw() {
                ctx.font = `${this.size}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
            }
            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.draw();
            }
        }

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.color = `hsl(${Math.random() * 60 + 200}, 100%, 70%)`;
                this.velocity = { x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4 };
                this.alpha = 1;
            }
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= 0.02;
                this.draw();
            }
        }

        function initGame() {
            currentStageIndex = 0;
            lives = 3;
            gameOver = false;
            setupStage();
        }

        function setupStage() {
            const stage = STAGES[currentStageIndex];
            player = new Player(canvas.width / 2, canvas.height - 80);
            asteroids = [];
            particles = [];
            stageDuration = stage.duration * 1000;
            stageTimer = stageDuration;
            lastTime = undefined;
            
            stageNameEl.textContent = stage.name;
            livesEl.textContent = lives;
            inGameUI.classList.remove('hidden');
            joystickContainer.classList.remove('hidden');
            overlay.classList.add('hidden');

            startSpawning();
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(animate);
        }

        let spawnInterval;
        function startSpawning() {
            clearInterval(spawnInterval);
            const stage = STAGES[currentStageIndex];
            spawnInterval = setInterval(spawnAsteroid, stage.spawnRate);
        }

        function spawnAsteroid() {
            if (gameOver) return;
            const stage = STAGES[currentStageIndex];
            const emoji = stage.asteroids[Math.floor(Math.random() * stage.asteroids.length)];
            let x, y;
            const edge = Math.floor(Math.random() * 4);
            if (edge === 0) { x = Math.random() * canvas.width; y = -30; }
            else if (edge === 1) { x = canvas.width + 30; y = Math.random() * canvas.height; }
            else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 30; }
            else { x = -30; y = Math.random() * canvas.height; }

            const targetX = player.x + (Math.random() - 0.5) * 100;
            const targetY = player.y + (Math.random() - 0.5) * 100;
            const angle = Math.atan2(targetY - y, targetX - x);
            const speed = Math.random() * (stage.maxSpeed - stage.minSpeed) + stage.minSpeed;
            const velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
            asteroids.push(new Asteroid(x, y, emoji, velocity));
        }

        function animate(currentTime) {
            if (gameOver) return;
            animationFrameId = requestAnimationFrame(animate);
            
            if (lastTime === undefined) lastTime = currentTime;
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            player.update();

            particles.forEach((p, i) => p.alpha <= 0 ? particles.splice(i, 1) : p.update());
            asteroids.forEach((a, i) => {
                a.update();
                const dist = Math.hypot(player.x - a.x, player.y - a.y);
                if (dist < player.size / 2 + a.size / 2) {
                    handleCollision(i);
                }
            });

            stageTimer -= deltaTime;
            timeProgressEl.style.width = `${Math.max(0, stageTimer / stageDuration) * 100}%`;
            if (stageTimer <= 0) {
                stageClear();
            }
        }

        function handleCollision(index) {
            for (let i = 0; i < 20; i++) particles.push(new Particle(player.x, player.y));
            asteroids.splice(index, 1);
            lives--;
            livesEl.textContent = lives;
            if (lives <= 0) {
                endGame("게임 오버!");
            }
        }

        function stageClear() {
            clearInterval(spawnInterval);
            currentStageIndex++;
            if (currentStageIndex >= STAGES.length) {
                endGame("모든 스테이지 클리어!");
            } else {
                titleEl.textContent = "스테이지 클리어!";
                subtitleEl.textContent = `다음: ${STAGES[currentStageIndex].name}`;
                startButton.textContent = "다음 스테이지";
                overlay.classList.remove('hidden');
                inGameUI.classList.add('hidden');
                joystickContainer.classList.add('hidden');
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
        
        function endGame(message) {
            gameOver = true;
            clearInterval(spawnInterval);
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            titleEl.textContent = message;

            let finalStageName = STAGES[currentStageIndex] ? STAGES[currentStageIndex].name : STAGES[STAGES.length - 1].name;
            subtitleEl.textContent = `최종 생존 스테이지: ${finalStageName}`;
            
            startButton.textContent = "다시 시작";
            overlay.classList.remove('hidden');
            inGameUI.classList.add('hidden');
            joystickContainer.classList.add('hidden');
        }

        startButton.addEventListener('click', () => {
            if (gameOver) {
                initGame();
            } else {
                setupStage();
            }
        });
        
        let joystickActive = false;
        function handleJoystick(e) {
            e.preventDefault();
            if (!joystickActive) return;
            const rect = joystickContainer.getBoundingClientRect();
            const touch = e.touches[0];
            let x = (touch.clientX - rect.left - rect.width / 2);
            let y = (touch.clientY - rect.top - rect.height / 2);
            
            const mag = Math.sqrt(x*x + y*y);
            if (mag > rect.width / 4) {
                x = (x / mag) * (rect.width / 4);
                y = (y / mag) * (rect.width / 4);
            }
            
            joystickHandle.style.transform = `translate(${x}px, ${y}px)`;
            
            joystickInput = { x: x / (rect.width / 4), y: y / (rect.width / 4) };
        }

        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault();
            joystickActive = true;
        }, { passive: false });

        joystickContainer.addEventListener('touchmove', handleJoystick, { passive: false });

        window.addEventListener('touchend', (e) => {
            joystickActive = false;
            joystickHandle.style.transform = 'translate(0, 0)';
            joystickInput = { x: 0, y: 0 };
        });
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>
�
