<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>동물들의 대탈주</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body, button, h1, p, div, input {
            font-family: 'Jua', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            background-color: #A7F3D0;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path d="M 10 10 C 20 20, 40 20, 50 10 S 70 0, 80 10 S 100 20, 100 20" stroke="%2368D391" fill="none" stroke-width="2"/><path d="M 0 50 C 10 40, 30 40, 40 50 S 60 60, 70 50 S 90 40, 100 50" stroke="%2368D391" fill="none" stroke-width="2"/></svg>');
            background-size: 100px 100px;
            transition: background-color 0.5s;
        }
        .progress-bar-container { width: 80%; height: 20px; background-color: rgba(0,0,0,0.3); border-radius: 10px; overflow: hidden; border: 2px solid white; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #68D391, #F6E05E); transition: width 0.1s linear; }
        #joystick-container { position: absolute; bottom: 30px; right: 30px; width: 120px; height: 120px; background: rgba(0, 0, 0, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; display: flex; align-items: center; justify-content: center; }
        #joystick-handle { width: 60px; height: 60px; background: rgba(255, 255, 255, 0.4); border-radius: 50%; position: absolute; transition: transform 0.1s; }
    </style>
</head>
<body class="bg-gray-800 text-white flex items-center justify-center min-h-screen m-0 p-0 overflow-hidden">

    <div id="game-container" class="relative w-full h-full max-w-lg aspect-[9/16] bg-black shadow-2xl">
        <canvas id="gameCanvas"></canvas>

        <div id="in-game-ui" class="absolute top-0 left-0 w-full p-4 hidden">
            <div class="flex justify-between items-center text-black">
                <div id="lives-ui" class="text-2xl bg-white/50 px-3 py-1 rounded-lg">❤️ <span id="lives">3</span></div>
                <div id="stage-name-ui" class="text-2xl bg-white/50 px-3 py-1 rounded-lg"><span id="stage-name"></span></div>
                <div id="survival-time-ui" class="text-2xl bg-white/50 px-3 py-1 rounded-lg hidden">시간: <span id="survival-time">0</span>s</div>
                <button id="pauseButton" class="text-2xl bg-white/50 hover:bg-white/70 px-3 py-1 rounded-lg transition-colors">⏸️</button>
            </div>
            <div id="progress-bar-wrapper" class="progress-bar-container mx-auto mt-2">
                <div id="time-progress" class="progress-bar" style="width: 100%;"></div>
            </div>
        </div>

        <div id="overlay" class="absolute inset-0 bg-black bg-opacity-60 flex flex-col items-center justify-center text-center p-4 z-10">
            <h1 id="title" class="text-6xl font-extrabold text-yellow-300 mb-4">동물들의 대탈주</h1>
            <p id="subtitle" class="text-xl mb-6">사육사가 되어 동물들을 피하세요!</p>

            <div id="nickname-section" class="flex flex-col items-center mb-6">
                <label for="nickname-input" class="text-xl mb-2">닉네임을 입력하세요:</label>
                <input type="text" id="nickname-input" class="px-4 py-2 text-lg text-black rounded-md mb-4" placeholder="닉네임" maxlength="10">
                <button id="setNicknameButton" class="px-8 py-3 bg-green-600 hover:bg-green-700 rounded-full text-xl font-bold shadow-lg">닉네임 설정</button>
            </div>

            <div id="main-menu-buttons" class="hidden flex-col space-y-4">
                <div class="flex space-x-4">
                    <button id="storyModeButton" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 rounded-full text-2xl font-bold shadow-lg">스토리</button>
                    <button id="infiniteModeButton" class="px-8 py-4 bg-purple-600 hover:bg-purple-700 rounded-full text-2xl font-bold shadow-lg">무한모드</button>
                </div>
                <button id="rankingButton" class="px-10 py-3 bg-yellow-600 hover:bg-yellow-700 rounded-full text-xl font-bold shadow-lg">랭킹 보기</button>
                <button id="helpButton" class="px-10 py-3 bg-gray-600 hover:bg-gray-700 rounded-full text-xl font-bold shadow-lg">게임 설명</button>
                <button id="changeNicknameButton" class="px-10 py-2 bg-gray-500 hover:bg-gray-600 rounded-full text-lg">닉네임 변경</button>
            </div>

            <div id="end-game-buttons" class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4 hidden mt-4">
                <button id="retryButton" class="px-8 py-3 bg-green-600 hover:bg-green-700 rounded-full text-2xl font-bold shadow-lg">스테이지 재시도</button>
                <button id="restartButton" class="px-8 py-3 bg-blue-600 hover:bg-blue-700 rounded-full text-2xl font-bold shadow-lg">메인 메뉴로</button>
                <button id="mainMenuButton" class="px-8 py-3 bg-gray-600 hover:bg-gray-700 rounded-full text-2xl font-bold shadow-lg hidden">메인 메뉴로</button>
            </div>
        </div>
        
        <div id="difficulty-select-overlay" class="absolute inset-0 bg-black bg-opacity-80 flex-col items-center justify-center text-center p-6 z-20 hidden">
            <h2 class="text-4xl font-bold text-yellow-300 mb-6">난이도 선택</h2>
            <div class="flex flex-col space-y-4">
                <button data-difficulty="easy" class="difficulty-btn px-12 py-4 bg-green-600 hover:bg-green-700 rounded-full text-2xl font-bold shadow-lg">이지</button>
                <button data-difficulty="normal" class="difficulty-btn px-12 py-4 bg-blue-600 hover:bg-blue-700 rounded-full text-2xl font-bold shadow-lg">노말</button>
                <button data-difficulty="hard" class="difficulty-btn px-12 py-4 bg-orange-600 hover:bg-orange-700 rounded-full text-2xl font-bold shadow-lg">하드</button>
                <button data-difficulty="crazy" class="difficulty-btn px-12 py-4 bg-red-600 hover:bg-red-700 rounded-full text-2xl font-bold shadow-lg">크레이지</button>
            </div>
            <button id="backToModeButton" class="mt-8 px-10 py-3 bg-gray-500 hover:bg-gray-600 rounded-full text-xl font-bold shadow-lg">뒤로 가기</button>
        </div>

        <div id="character-select-overlay" class="absolute inset-0 bg-black bg-opacity-80 flex-col items-center justify-center text-center p-6 z-20 hidden">
            <h2 class="text-4xl font-bold text-yellow-300 mb-6">사육사 선택</h2>
            <div id="character-grid" class="grid grid-cols-3 gap-4"></div>
            <button id="backToDifficultyButton" class="mt-8 px-10 py-3 bg-gray-500 hover:bg-gray-600 rounded-full text-xl font-bold shadow-lg">뒤로 가기</button>
            <button id="backToMainButton" class="mt-4 px-10 py-3 bg-gray-500 hover:bg-gray-600 rounded-full text-xl font-bold shadow-lg">메인으로</button>
        </div>

        <div id="stage-clear-overlay" class="absolute inset-0 bg-black bg-opacity-80 flex-col items-center justify-center text-center p-6 z-20 hidden">
            <h2 class="text-4xl font-bold text-green-400 mb-4">🎉 구역 클리어! 🎉</h2>
            <p class="text-2xl text-yellow-300 mb-6">다음 구역으로 진행하시겠습니까?</p>
            <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                <button id="nextStageButton" class="px-8 py-4 bg-green-600 hover:bg-green-700 rounded-full text-2xl font-bold shadow-lg">다음 구역으로</button>
                <button id="pauseGameButton" class="px-8 py-4 bg-blue-600 hover:bg-blue-700 rounded-full text-2xl font-bold shadow-lg">잠시 쉬기</button>
            </div>
        </div>

        <div id="help-overlay" class="absolute inset-0 bg-black bg-opacity-80 flex-col items-center justify-center text-center p-6 z-20 hidden">
            <h2 class="text-4xl font-bold text-yellow-300 mb-6">게임 설명</h2>
            <div class="text-left max-w-sm space-y-3 text-lg">
                <p>🧑‍🌾 <span class="font-bold">목표:</span> 탈출한 동물들을 피하며 각 구역에서 살아남으세요!</p>
                <p>🕹️ <span class="font-bold">조작:</span> 조이스틱으로 사육사를 조종합니다.</p>
                <p class="font-bold text-yellow-400 mt-4">아이템</p>
                <p>🥅 <span class="font-bold">튼튼한 그물:</span> 5초간 충돌을 1회 막아줍니다.</p>
                <p>💉 <span class="font-bold">마취총:</span> 화면의 모든 동물을 잠재웁니다.</p>
                <p>🚙 <span class="font-bold">지프차:</span> 안전한 곳으로 즉시 이동합니다.</p>
                <p>🍖 <span class="font-bold">먹이:</span> 5초간 모든 동물이 느려집니다.</p>
            </div>
            <button id="closeHelpButton" class="mt-8 px-10 py-3 bg-red-500 hover:bg-red-600 rounded-full text-xl font-bold shadow-lg">닫기</button>
        </div>

        <div id="ranking-overlay" class="absolute inset-0 bg-black bg-opacity-90 flex-col items-center p-6 z-30 hidden text-center">
            <h2 class="text-4xl font-bold text-yellow-300 mb-4">명예의 전당</h2>
            <div class="flex border-b-2 border-yellow-300 w-full max-w-sm mb-4">
                <button id="storyRankTab" class="flex-1 py-2 text-xl border-b-4 border-yellow-500 text-yellow-400">스토리 모드</button>
                <button id="infiniteRankTab" class="flex-1 py-2 text-xl border-b-4 border-transparent">무한 모드</button>
            </div>
            <div id="ranking-list" class="w-full max-w-sm text-lg space-y-2 overflow-y-auto"></div>
            <button id="closeRankingButton" class="mt-8 px-10 py-3 bg-red-500 hover:bg-red-600 rounded-full text-xl font-bold shadow-lg">닫기</button>
        </div>

        <div id="joystick-container" class="hidden">
            <div id="joystick-handle"></div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        document.addEventListener('DOMContentLoaded', () => {
            let db, auth, userId, userNickname;
            let animationFrameId;
            let player, animals, particles, lives, gameOver, currentStageIndex, items;
            let stageTimer, stageDuration, lastTime, globalSpeedModifier, survivalTime;
            let joystickInput = { x: 0, y: 0 };
            const CHARACTERS = ['🧑‍🌾', '👩‍🌾', '👨‍🌾', '👮', '🚜'];
            let selectedCharacter = CHARACTERS[0];
            let currentGameMode = null;
            let selectedDifficulty = 'normal';
            let gamePaused = false;
            gameOver = true;
            
            const isRankingEnabled = new URLSearchParams(window.location.search).get('rank_on') === '1';
            const isNicknameEnabled = new URLSearchParams(window.location.search).get('nickname_on') === '1';

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const overlay = document.getElementById('overlay');
            const storyModeButton = document.getElementById('storyModeButton');
            const infiniteModeButton = document.getElementById('infiniteModeButton');
            const retryButton = document.getElementById('retryButton');
            const restartButton = document.getElementById('restartButton');
            const helpButton = document.getElementById('helpButton');
            const helpOverlay = document.getElementById('help-overlay');
            const closeHelpButton = document.getElementById('closeHelpButton');
            const characterSelectOverlay = document.getElementById('character-select-overlay');
            const characterGrid = document.getElementById('character-grid');
            const backToMainButton = document.getElementById('backToMainButton');
            const titleEl = document.getElementById('title');
            const subtitleEl = document.getElementById('subtitle');
            const inGameUI = document.getElementById('in-game-ui');
            const livesUI = document.getElementById('lives-ui');
            const livesEl = document.getElementById('lives');
            const stageNameUI = document.getElementById('stage-name-ui');
            const stageNameEl = document.getElementById('stage-name');
            const survivalTimeUI = document.getElementById('survival-time-ui');
            const survivalTimeEl = document.getElementById('survival-time');
            const progressBarWrapper = document.getElementById('progress-bar-wrapper');
            const timeProgressEl = document.getElementById('time-progress');
            const joystickContainer = document.getElementById('joystick-container');
            const joystickHandle = document.getElementById('joystick-handle');
            const endGameButtons = document.getElementById('end-game-buttons');
            const nicknameSection = document.getElementById('nickname-section');
            const nicknameInput = document.getElementById('nickname-input');
            const setNicknameButton = document.getElementById('setNicknameButton');
            const rankingButton = document.getElementById('rankingButton');
            const rankingOverlay = document.getElementById('ranking-overlay');
            const closeRankingButton = document.getElementById('closeRankingButton');
            const storyRankTab = document.getElementById('storyRankTab');
            const infiniteRankTab = document.getElementById('infiniteRankTab');
            const rankingList = document.getElementById('ranking-list');
            const mainMenuButtons = document.getElementById('main-menu-buttons');
            const changeNicknameButton = document.getElementById('changeNicknameButton');
            const difficultySelectOverlay = document.getElementById('difficulty-select-overlay');
            const difficultyButtons = document.querySelectorAll('.difficulty-btn');
            const backToModeButton = document.getElementById('backToModeButton');
            const backToDifficultyButton = document.getElementById('backToDifficultyButton');
            const pauseButton = document.getElementById('pauseButton');
            const stageClearOverlay = document.getElementById('stage-clear-overlay');
            const nextStageButton = document.getElementById('nextStageButton');
            const pauseGameButton = document.getElementById('pauseGameButton');
            const mainMenuButton = document.getElementById('mainMenuButton');
            
            const STAGES = [
                { name: "1. 농장", duration: 15, spawnRate: 500, minSpeed: 1, maxSpeed: 2, animals: ['🐔', '🐷', '🐮', '🐑'] },
                { name: "2. 초원", duration: 15, spawnRate: 450, minSpeed: 1.2, maxSpeed: 2.5, animals: ['🦓', '🦒', '🐘', '🦏'] },
                { name: "3. 정글", duration: 20, spawnRate: 400, minSpeed: 1.5, maxSpeed: 3, animals: ['🐒', '🐍', '🐅', '🦍'] },
                { name: "4. 극지방", duration: 20, spawnRate: 380, minSpeed: 1.8, maxSpeed: 3.5, animals: ['🐧', '🐻‍❄️', '🦊', '🦭'] },
                { name: "5. 보스: 거대 킹크랩", duration: 25, isBossStage: true, bossEmoji: '🦀', spawnRate: 800, minSpeed: 1, maxSpeed: 2, animals: ['💧'] },
                { name: "6. 바다", duration: 25, spawnRate: 350, minSpeed: 2.2, maxSpeed: 4.0, animals: ['🐙', '🐡', '🐠', '🐬'] },
                { name: "7. 사막", duration: 25, spawnRate: 320, minSpeed: 2.4, maxSpeed: 4.2, animals: ['🐪', '🦎', '🦂', '🐍'] },
                { name: "8. 산악 지대", duration: 25, spawnRate: 300, minSpeed: 2.5, maxSpeed: 4.5, animals: ['🐐', '🦅', '🐺'] },
                { name: "9. 늪지대", duration: 30, spawnRate: 280, minSpeed: 2.6, maxSpeed: 4.8, animals: ['🐸', '🐊', '🦟'] },
                { name: "10. 보스: 분노한 곰", duration: 30, isBossStage: true, bossEmoji: '🐻', spawnRate: 700, minSpeed: 1.5, maxSpeed: 2.5, animals: ['🐾'] },
                { name: "11. 판타지 숲", duration: 30, spawnRate: 280, minSpeed: 2.8, maxSpeed: 5.0, animals: ['🦄', '🧚‍♀️', '🍄'] },
                { name: "12. 공룡 시대", duration: 30, spawnRate: 250, minSpeed: 3.0, maxSpeed: 5.2, animals: ['🦖', '🦕', '☄️'] },
                { name: "13. 장난감 상자", duration: 30, spawnRate: 250, minSpeed: 3.2, maxSpeed: 5.5, animals: ['🧸', '🚂', '🪁'] },
                { name: "14. 유령의 집", duration: 35, spawnRate: 220, minSpeed: 3.4, maxSpeed: 5.8, animals: ['👻', '🎃', '💀', '🦇'] },
                { name: "15. 보스: 우주 문어", duration: 35, isBossStage: true, bossEmoji: '🐙', spawnRate: 600, minSpeed: 2, maxSpeed: 3, animals: ['🦠'] },
                { name: "16. 과자 나라", duration: 35, spawnRate: 200, minSpeed: 3.6, maxSpeed: 6.2, animals: ['🍩', '🍪', '🧁', '🍰'] },
                { name: "17. 신화 속 동물", duration: 35, spawnRate: 200, minSpeed: 3.8, maxSpeed: 6.5, animals: ['🐉', '🐲', '🧜‍♀️'] },
                { name: "18. 로봇 공장", duration: 40, spawnRate: 180, minSpeed: 4.0, maxSpeed: 6.8, animals: ['🤖', '🦾', '⚙️'] },
                { name: "19. 외계 행성", duration: 40, spawnRate: 150, minSpeed: 4.2, maxSpeed: 7.0, animals: ['👽', '🛸', '👾'] },
                { name: "20. 최종 보스: 대혼돈", duration: 60, isBossStage: true, bossEmoji: '😈', spawnRate: 500, minSpeed: 3, maxSpeed: 5, animals: ['💥', '🎯', '🔥'] }
            ];
            const ALL_ANIMALS = [...new Set(STAGES.flatMap(s => s.animals))];
            const DIFFICULTY_SETTINGS = {
                easy: { speed: 0.7, spawn: 1.3 },
                normal: { speed: 1.0, spawn: 1.0 },
                hard: { speed: 1.2, spawn: 0.8 },
                crazy: { speed: 1.5, spawn: 0.6 }
            };

            function resizeCanvas() {
                const container = document.getElementById('game-container');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            }

            async function setupFirebase() {
                try {
                    const firebaseConfig = {
                        apiKey: "AIzaSyCOinJqnLyonSS3nrYgauBmBOWGB1fdrHI",
                        authDomain: "gamestudio1-3af17.firebaseapp.com",
                        databaseURL: "https://gamestudio1-3af17-default-rtdb.asia-southeast1.firebasedatabase.app",
                        projectId: "gamestudio1-3af17",
                        storageBucket: "gamestudio1-3af17.appspot.com",
                        messagingSenderId: "515670984841",
                        appId: "1:515670984841:web:d6bc6b19e101bd931bde58",
                        measurementId: "G-ECV6KSXEJK"
                    };
                    
                    if (!firebaseConfig.apiKey) {
                        throw new Error("Firebase config is empty.");
                    }

                    const app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    onAuthStateChanged(auth, user => {
                        if (user) {
                            userId = user.uid;
                            checkNickname();
                        } else {
                            signInAnonymously(auth).catch(error => {
                                console.error("Anonymous sign-in failed:", error);
                                if (error.code === 'auth/configuration-not-found') {
                                    console.warn("Firebase 랭킹 기능을 사용할 수 없습니다. Firebase 콘솔 > Authentication > Sign-in method에서 '익명' 로그인을 활성화해주세요.");
                                    disableRankingFeatures();
                                }
                                checkNickname();
                            });
                        }
                    });
                } catch (e) {
                    console.error("Firebase initialization failed.", e);
                    disableRankingFeatures();
                    checkNickname();
                }
            }

            function checkNickname() {
                userNickname = localStorage.getItem('userNickname');
                if (isRankingEnabled && isNicknameEnabled && !userNickname) {
                    nicknameSection.classList.remove('hidden');
                    mainMenuButtons.classList.add('hidden');
                } else {
                    showMainMenuState();
                }
            }
            
            function disableRankingFeatures() {
                rankingButton.textContent = "랭킹 (비활성화)";
                rankingButton.disabled = true;
                rankingButton.classList.add("opacity-50", "cursor-not-allowed");
            }

            async function saveScore(mode, scoreValue) {
                if (!isRankingEnabled || !db || !userId || !userNickname) return;
                
                const localKey = mode === 'story' ? 'bestStoryStage' : 'bestInfiniteTime';
                const localBest = parseFloat(localStorage.getItem(localKey) || 0);

                let isNewLocalBest = false;
                if (mode === 'story' && scoreValue > localBest) {
                    isNewLocalBest = true;
                } else if (mode === 'infinite' && scoreValue > localBest) {
                    isNewLocalBest = true;
                }

                if (isNewLocalBest) {
                    localStorage.setItem(localKey, scoreValue);
                    
                    const scoreRef = doc(db, `scores/${userId}`);
                    let dataToSave = { userId, nickname: userNickname };
                    if (mode === 'story') {
                        dataToSave.storyModeScore = scoreValue;
                    } else {
                        dataToSave.infiniteModeScore = scoreValue;
                    }
                    await setDoc(scoreRef, dataToSave, { merge: true });
                }
            }

            async function showRanking(mode) {
                if (!db) {
                    rankingList.innerHTML = '<p>랭킹을 불러올 수 없습니다.</p>';
                    return;
                }
                rankingList.innerHTML = '<p>로딩 중...</p>';
                
                const field = mode === 'story' ? 'storyModeScore' : 'infiniteModeScore';
                const q = query(collection(db, "scores"), orderBy(field, "desc"), limit(10));
                
                try {
                    const querySnapshot = await getDocs(q);
                    let rankHtml = '';
                    let rank = 1;
                    querySnapshot.forEach((doc) => {
                        const data = doc.data();
                        const score = mode === 'story' ? `${data.storyModeScore || 0} 스테이지` : `${(data.infiniteModeScore || 0).toFixed(1)}초`;
                        rankHtml += `<div class="flex justify-between p-2 ${rank % 2 === 0 ? 'bg-gray-700' : ''} rounded">
                                        <span>${rank}. ${data.nickname}</span>
                                        <span>${score}</span>
                                     </div>`;
                        rank++;
                    });

                    if (rankHtml === '') {
                        rankHtml = '<p>아직 랭킹이 없습니다.</p>';
                    }
                    rankingList.innerHTML = rankHtml;
                } catch(e) {
                    console.error("Error fetching ranking:", e);
                    rankingList.innerHTML = '<p>랭킹을 불러오는 데 실패했습니다. Firestore 규칙을 확인하세요.</p>';
                }
            }

            class Player {
                constructor(x, y) {
                    this.x = x; this.y = y; this.emoji = selectedCharacter; this.size = 40;
                    this.angle = -Math.PI / 2; this.speed = 4; this.shielded = false;
                }
                draw() {
                    if (this.shielded) {
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(59, 130, 246, 0.4)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(59, 130, 246, 1)';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.font = `${this.size}px serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.emoji, 0, 0);
                    ctx.restore();
                }
                update() {
                    this.x += joystickInput.x * this.speed;
                    this.y += joystickInput.y * this.speed;

                    if (this.x - this.size/2 < 0) this.x = this.size/2;
                    if (this.x + this.size/2 > canvas.width) this.x = canvas.width - this.size/2;
                    if (this.y - this.size/2 < 0) this.y = this.size/2;
                    if (this.y + this.size/2 > canvas.height) this.y = canvas.height - this.size/2;

                    if (joystickInput.x !== 0 || joystickInput.y !== 0) {
                        this.angle = Math.atan2(joystickInput.y, joystickInput.x) + Math.PI / 2;
                    }
                    this.draw();
                }
            }

            class Animal {
                constructor(x, y, emoji, velocity, type = 'normal') {
                    this.x = x; this.y = y; this.emoji = emoji;
                    this.size = 25 + Math.random() * 25;
                    this.velocity = velocity;
                    this.type = type;
                    this.homingCooldown = 60;
                }
                draw() {
                    ctx.font = `${this.size}px serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.emoji, this.x, this.y);
                }
                update() {
                    if (this.type === 'homing' && this.homingCooldown > 0 && player) {
                        const angle = Math.atan2(player.y - this.y, player.x - this.x);
                        const speed = Math.hypot(this.velocity.x, this.velocity.y);
                        this.velocity.x = Math.cos(angle) * speed;
                        this.velocity.y = Math.sin(angle) * speed;
                        this.homingCooldown--;
                    }
                    this.x += this.velocity.x * globalSpeedModifier;
                    this.y += this.velocity.y * globalSpeedModifier;
                    this.draw();
                }
            }

            class Boss extends Animal {
                constructor(x, y, emoji, velocity) {
                    super(x, y, emoji, velocity);
                    this.size = 100;
                    this.attackInterval = setInterval(() => this.attack(), 2000);
                }
                attack() {
                    if(gameOver || !player) return;
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const speed = STAGES[currentStageIndex].maxSpeed + 1;
                    const velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                    const emoji = STAGES[currentStageIndex].animals[0];
                    animals.push(new Animal(this.x, this.y, emoji, velocity));
                }
                update() {
                    this.x += this.velocity.x * globalSpeedModifier * 0.5;
                    this.y += this.velocity.y * globalSpeedModifier * 0.5;
                    if(this.x < this.size / 2 || this.x > canvas.width - this.size / 2) this.velocity.x *= -1;
                    if(this.y < this.size / 2 || this.y > canvas.height/2) this.velocity.y *= -1;
                    this.draw();
                }
            }

            class Particle {
                constructor(x, y) {
                    this.x = x; this.y = y; this.size = Math.random() * 5 + 2;
                    this.color = `hsl(${Math.random() * 60 + 100}, 100%, 70%)`;
                    this.velocity = { x: (Math.random() - 0.5) * 4, y: (Math.random() - 0.5) * 4 };
                    this.alpha = 1;
                }
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                update() {
                    this.x += this.velocity.x;
                    this.y += this.velocity.y;
                    this.alpha -= 0.02;
                    this.draw();
                }
            }
            
            class Item {
                constructor(x, y, type) {
                    this.x = x; this.y = y; this.type = type;
                    this.emoji = type === 'shield' ? '🥅' : (type === 'bomb' ? '💉' : (type === 'teleport' ? '🚙' : '🍖'));
                    this.size = 30;
                }
                draw() {
                    ctx.font = `${this.size}px serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.emoji, this.x, this.y);
                }
                update() { this.draw(); }
            }

            function initGame() {
                lives = 3;
                gameOver = false;
                if (currentGameMode === 'story') {
                    currentStageIndex = 0;
                    setupStage();
                } else {
                    setupInfiniteMode();
                }
            }

            function retryCurrentStage() {
                lives = 3;
                gameOver = false;
                setupStage();
            }

            function setupStage() {
                const stage = STAGES[currentStageIndex];
                player = new Player(canvas.width / 2, canvas.height - 80);
                animals = []; particles = []; items = [];
                stageDuration = stage.duration * 1000;
                stageTimer = stageDuration;
                lastTime = undefined;
                globalSpeedModifier = 1;
                gamePaused = false;
                
                stageNameUI.classList.remove('hidden');
                livesUI.classList.remove('hidden');
                progressBarWrapper.classList.remove('hidden');
                survivalTimeUI.classList.add('hidden');
                stageNameEl.textContent = stage.name;
                livesEl.textContent = lives;
                inGameUI.classList.remove('hidden');
                joystickContainer.classList.remove('hidden');
                overlay.classList.add('hidden');
                characterSelectOverlay.classList.add('hidden');

                startSpawning();
                
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(animate);
            }
            
            function setupInfiniteMode() {
                player = new Player(canvas.width / 2, canvas.height - 80);
                animals = []; particles = []; items = [];
                lastTime = undefined;
                globalSpeedModifier = 1;
                survivalTime = 0;
                gamePaused = false;
                
                livesEl.textContent = lives;
                stageNameUI.classList.add('hidden');
                progressBarWrapper.classList.add('hidden');
                survivalTimeUI.classList.remove('hidden');
                livesUI.classList.remove('hidden');
                inGameUI.classList.remove('hidden');
                joystickContainer.classList.remove('hidden');
                overlay.classList.add('hidden');
                characterSelectOverlay.classList.add('hidden');

                startSpawning();

                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(animate);
            }

            let spawnInterval, itemInterval;
            function startSpawning() {
                clearInterval(spawnInterval);
                clearInterval(itemInterval);
                const diff = DIFFICULTY_SETTINGS[selectedDifficulty];
                if (currentGameMode === 'story') {
                    const stage = STAGES[currentStageIndex];
                    if (stage.isBossStage) {
                        const boss = new Boss(canvas.width / 2, 150, stage.bossEmoji, {x: 1, y: 1});
                        animals.push(boss);
                    }
                    spawnInterval = setInterval(spawnAnimal, stage.spawnRate * diff.spawn);
                } else { // Infinite Mode
                    spawnInterval = setInterval(spawnAnimal, 500 * diff.spawn);
                }
                itemInterval = setInterval(spawnItem, 8000);
            }

            function spawnAnimal() {
                if (gameOver || !player) return;
                
                let emoji, speedMultiplier = 1;
                const diff = DIFFICULTY_SETTINGS[selectedDifficulty];

                if (currentGameMode === 'story') {
                    const stage = STAGES[currentStageIndex];
                    emoji = stage.animals[Math.floor(Math.random() * stage.animals.length)];
                } else {
                    const animalIndex = Math.min(ALL_ANIMALS.length - 1, Math.floor(survivalTime / 10));
                    emoji = ALL_ANIMALS[Math.floor(Math.random() * (animalIndex + 1))];
                    speedMultiplier = 1 + (survivalTime / 60);
                }

                let x, y;
                const edge = Math.floor(Math.random() * 4);
                if (edge === 0) { x = Math.random() * canvas.width; y = -30; }
                else if (edge === 1) { x = canvas.width + 30; y = Math.random() * canvas.height; }
                else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 30; }
                else { x = -30; y = Math.random() * canvas.height; }

                const targetX = player.x + (Math.random() - 0.5) * 100;
                const targetY = player.y + (Math.random() - 0.5) * 100;
                const angle = Math.atan2(targetY - y, targetX - x);
                const speed = (Math.random() * 1.5 + 1) * speedMultiplier * diff.speed;
                const velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                
                let type = 'normal';
                if (Math.random() < 0.1) {
                    type = Math.random() < 0.5 ? 'split' : 'homing';
                }
                const emojiToUse = type === 'split' ? '💥' : (type === 'homing' ? '🎯' : emoji);
                animals.push(new Animal(x, y, emojiToUse, velocity, type));
            }

            function spawnItem() {
                if (gameOver) return;
                const itemTypes = ['shield', 'bomb', 'teleport', 'slowmo'];
                const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                const x = Math.random() * (canvas.width - 60) + 30;
                const y = Math.random() * (canvas.height - 100) + 50;
                items.push(new Item(x, y, type));
            }

            function animate(currentTime) {
                if (gameOver || gamePaused) return;
                animationFrameId = requestAnimationFrame(animate);
                
                if (lastTime === undefined) lastTime = currentTime;
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                player.update();
                particles.forEach((p, i) => p.alpha <= 0 ? particles.splice(i, 1) : p.update());
                items.forEach((item, i) => {
                    item.update();
                    const dist = Math.hypot(player.x - item.x, player.y - item.y);
                    if (dist < player.size / 2 + item.size / 2) {
                        activateItem(item.type);
                        items.splice(i, 1);
                    }
                });

                animals.forEach((a, i) => {
                    a.update();
                    const dist = Math.hypot(player.x - a.x, player.y - a.y);
                    if (dist < player.size / 2 + a.size / 2) {
                        handleCollision(i, a);
                    }
                });

                if (currentGameMode === 'story') {
                    stageTimer -= deltaTime;
                    timeProgressEl.style.width = `${Math.max(0, stageTimer / stageDuration) * 100}%`;
                    if (stageTimer <= 0) stageClear();
                } else {
                    survivalTime += deltaTime / 1000;
                    survivalTimeEl.textContent = survivalTime.toFixed(1);
                }
            }

            function activateItem(type) {
                if (type === 'shield') {
                    player.shielded = true;
                    setTimeout(() => { player.shielded = false; }, 5000);
                } else if (type === 'bomb') {
                    animals.forEach(a => {
                         if (!(a instanceof Boss)) {
                            for (let i = 0; i < 10; i++) particles.push(new Particle(a.x, a.y));
                         }
                    });
                    animals = animals.filter(a => a instanceof Boss);
                } else if (type === 'teleport') {
                    player.x = Math.random() * (canvas.width - 100) + 50;
                    player.y = Math.random() * (canvas.height - 100) + 50;
                    for (let i = 0; i < 30; i++) particles.push(new Particle(player.x, player.y));
                } else if (type === 'slowmo') {
                    globalSpeedModifier = 0.5;
                    setTimeout(() => { globalSpeedModifier = 1; }, 5000);
                }
            }
            function handleCollision(index, animal) {
                if (player.shielded) {
                    player.shielded = false;
                    if (!(animal instanceof Boss)) animals.splice(index, 1);
                    return;
                }

                if (animal.type === 'split') {
                    for (let i = 0; i < 3; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = STAGES[currentStageIndex].maxSpeed;
                        const velocity = { x: Math.cos(angle) * speed, y: Math.sin(angle) * speed };
                        animals.push(new Animal(animal.x, animal.y, '🔥', velocity));
                    }
                }

                for (let i = 0; i < 20; i++) particles.push(new Particle(player.x, player.y));
                if (!(animal instanceof Boss)) animals.splice(index, 1);
                lives--;
                livesEl.textContent = lives;
                if (lives <= 0) {
                    endGame("게임 오버!");
                }
            }
            function stageClear() {
                clearInterval(spawnInterval);
                clearInterval(itemInterval);
                animals.forEach(a => { if (a instanceof Boss) clearInterval(a.attackInterval); });
                currentStageIndex++;
                if (currentStageIndex >= STAGES.length) {
                    endGame("모든 동물원에서 살아남았습니다!");
                    saveScore('story', currentStageIndex);
                } else {
                    // 스테이지 클리어 화면 표시
                    stageClearOverlay.classList.remove('hidden');
                    stageClearOverlay.classList.add('flex');
                    inGameUI.classList.add('hidden');
                    joystickContainer.classList.add('hidden');
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }
            
            function endGame(message) {
                gameOver = true;
                clearInterval(spawnInterval);
                clearInterval(itemInterval);
                animals.forEach(a => { if (a instanceof Boss) clearInterval(a.attackInterval); });
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
                
                titleEl.textContent = message;
                
                if (currentGameMode === 'story') {
                    saveScore('story', currentStageIndex);
                    let finalStageName = STAGES[currentStageIndex] ? STAGES[currentStageIndex].name : STAGES[STAGES.length - 1].name;
                    subtitleEl.textContent = `최종 생존 구역: ${finalStageName}`;
                    mainMenuButton.classList.add('hidden');
                    if (message !== "모든 동물원에서 살아남았습니다!") {
                        retryButton.classList.remove('hidden');
                        restartButton.textContent = "메인 메뉴로";
                    } else {
                        retryButton.classList.add('hidden');
                        restartButton.textContent = "처음부터 다시";
                    }
                } else { // Infinite Mode
                    saveScore('infinite', survivalTime);
                    subtitleEl.textContent = `최종 생존 시간: ${survivalTime.toFixed(1)}초`;
                    retryButton.classList.add('hidden');
                    restartButton.textContent = "다시 도전";
                    mainMenuButton.classList.remove('hidden');
                }
                
                overlay.classList.remove('hidden');
                inGameUI.classList.add('hidden');
                joystickContainer.classList.add('hidden');
                endGameButtons.classList.remove('hidden');
                mainMenuButtons.classList.add('hidden');
            }

            function showMainMenuState() {
                titleEl.textContent = "동물들의 대탈주";
                overlay.classList.remove('hidden');
                characterSelectOverlay.classList.add('hidden');
                endGameButtons.classList.add('hidden');
                difficultySelectOverlay.classList.add('hidden');
                
                userNickname = localStorage.getItem('userNickname');
                if (userNickname) {
                    subtitleEl.textContent = `${userNickname}님, 환영합니다!`;
                    nicknameSection.classList.add('hidden');
                    mainMenuButtons.classList.remove('hidden');
                } else {
                    subtitleEl.textContent = "사육사가 되어 동물들을 피하세요!";
                    nicknameSection.classList.remove('hidden');
                    mainMenuButtons.classList.add('hidden');
                }
            }

            function populateCharacterSelect() {
                characterGrid.innerHTML = '';
                CHARACTERS.forEach(char => {
                    const charButton = document.createElement('button');
                    charButton.className = 'text-6xl p-4 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors';
                    charButton.textContent = char;
                    charButton.onclick = () => {
                        selectedCharacter = char;
                        initGame();
                    };
                    characterGrid.appendChild(charButton);
                });
            }

            function showCharacterSelect() {
                difficultySelectOverlay.classList.add('hidden');
                characterSelectOverlay.classList.remove('hidden');
                characterSelectOverlay.classList.add('flex');
            }

            function showDifficultySelect(mode) {
                 if (isRankingEnabled && !userNickname) {
                    nicknameSection.classList.remove('hidden');
                    mainMenuButtons.classList.add('hidden');
                    return;
                }
                currentGameMode = mode;
                overlay.classList.add('hidden');
                difficultySelectOverlay.classList.remove('hidden');
                difficultySelectOverlay.classList.add('flex');
            }

            storyModeButton.addEventListener('click', () => showDifficultySelect('story'));
            infiniteModeButton.addEventListener('click', () => showDifficultySelect('infinite'));
            retryButton.addEventListener('click', () => retryCurrentStage());
            restartButton.addEventListener('click', () => {
                if (gameOver) {
                    if (currentGameMode === 'story' && retryButton.classList.contains('hidden')) {
                        // 모든 스테이지 클리어한 경우 처음부터 다시
                        currentStageIndex = 0;
                        initGame();
                    } else if (currentGameMode === 'infinite') {
                        // 무한 모드 재시작
                        initGame();
                    } else {
                        // 메인 메뉴로 돌아가기
                        showMainMenuState();
                    }
                } else {
                    // 스테이지 클리어 시 다음 스테이지로
                    setupStage();
                }
            });
            helpButton.addEventListener('click', () => { helpOverlay.classList.remove('hidden'); helpOverlay.classList.add('flex'); });
            closeHelpButton.addEventListener('click', () => { helpOverlay.classList.add('hidden'); helpOverlay.classList.remove('flex'); });
            backToMainButton.addEventListener('click', () => showMainMenuState());
            backToModeButton.addEventListener('click', () => {
                difficultySelectOverlay.classList.add('hidden');
                overlay.classList.remove('hidden');
            });
            backToDifficultyButton.addEventListener('click', () => {
                characterSelectOverlay.classList.add('hidden');
                difficultySelectOverlay.classList.remove('hidden');
                difficultySelectOverlay.classList.add('flex');
            });
            rankingButton.addEventListener('click', () => {
                rankingOverlay.classList.remove('hidden');
                rankingOverlay.classList.add('flex');
                showRanking('story');
            });
            closeRankingButton.addEventListener('click', () => {
                rankingOverlay.classList.add('hidden');
                rankingOverlay.classList.remove('flex');
            });
            storyRankTab.addEventListener('click', () => {
                storyRankTab.classList.add('border-yellow-500', 'text-yellow-400');
                infiniteRankTab.classList.remove('border-yellow-500', 'text-yellow-400');
                showRanking('story');
            });
            infiniteRankTab.addEventListener('click', () => {
                infiniteRankTab.classList.add('border-yellow-500', 'text-yellow-400');
                storyRankTab.classList.remove('border-yellow-500', 'text-yellow-400');
                showRanking('infinite');
            });
            
            difficultyButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    selectedDifficulty = e.target.dataset.difficulty;
                    showCharacterSelect();
                });
            });

            let joystickActive = false;
            function handleJoystick(e) {
                e.preventDefault();
                if (!joystickActive) return;
                const rect = joystickContainer.getBoundingClientRect();
                const touch = e.touches[0];
                let x = (touch.clientX - rect.left - rect.width / 2);
                let y = (touch.clientY - rect.top - rect.height / 2);
                
                const mag = Math.sqrt(x*x + y*y);
                if (mag > rect.width / 4) {
                    x = (x / mag) * (rect.width / 4);
                    y = (y / mag) * (rect.width / 4);
                }
                
                joystickHandle.style.transform = `translate(${x}px, ${y}px)`;
                
                joystickInput = { x: x / (rect.width / 4), y: y / (rect.width / 4) };
            }
            
            joystickContainer.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
            }, { passive: false });

            joystickContainer.addEventListener('touchmove', handleJoystick, { passive: false });

            window.addEventListener('touchend', (e) => {
                joystickActive = false;
                joystickHandle.style.transform = 'translate(0, 0)';
                joystickInput = { x: 0, y: 0 };
            });
            
            setNicknameButton.addEventListener('click', () => {
                const nickname = nicknameInput.value.trim();
                if (nickname) {
                    userNickname = nickname;
                    localStorage.setItem('userNickname', userNickname);
                    showMainMenuState();
                } else {
                    alert('닉네임을 입력해주세요!');
                }
            });
            
            changeNicknameButton.addEventListener('click', () => {
                mainMenuButtons.classList.add('hidden');
                nicknameSection.classList.remove('hidden');
            });

            // 일시정지 버튼
            pauseButton.addEventListener('click', () => {
                if (!gameOver && !gamePaused) {
                    gamePaused = true;
                    pauseButton.textContent = '▶️';
                    pauseButton.title = '게임 재개';
                } else if (!gameOver && gamePaused) {
                    gamePaused = false;
                    pauseButton.textContent = '⏸️';
                    pauseButton.title = '게임 일시정지';
                    lastTime = undefined; // 애니메이션 재시작
                    animate(performance.now());
                }
            });

            // 다음 스테이지 버튼
            nextStageButton.addEventListener('click', () => {
                stageClearOverlay.classList.add('hidden');
                stageClearOverlay.classList.remove('flex');
                setupStage();
            });

            // 잠시 쉬기 버튼
            pauseGameButton.addEventListener('click', () => {
                stageClearOverlay.classList.add('hidden');
                stageClearOverlay.classList.remove('flex');
                showMainMenuState();
            });

            // 메인 메뉴 버튼
            mainMenuButton.addEventListener('click', () => {
                showMainMenuState();
            });

            window.addEventListener('resize', resizeCanvas);
            
            resizeCanvas();
            populateCharacterSelect();
            if (isRankingEnabled) {
                setupFirebase();
            } else {
                rankingButton.style.display = 'none';
                checkNickname();
            }
        });
    </script>
</body>
</html>
