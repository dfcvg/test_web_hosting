<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>í• ë” í™€</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }

        .screen {
            pointer-events: all;
            background-color: rgba(0, 0, 0, 0.7);
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: absolute;
            transition: opacity 0.5s;
            overflow-y: auto;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        .title {
            font-size: 4em;
            color: #0ff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #0ff;
        }

        .subtitle {
            font-size: 1.2em;
            margin-top: 20px;
            color: #f0f;
            text-shadow: 0 0 5px #f0f;
            line-height: 1.5;
        }

        .button {
            margin-top: 40px;
            padding: 15px 30px;
            font-size: 24px;
            font-weight: bold;
            color: #000;
            background-color: #0ff;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 15px #0ff, 0 0 25px #0ff;
        }

        .button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px #0ff, 0 0 40px #0ff;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 2em;
            color: #fff;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #game-back-button {
            background-color: rgba(136, 136, 136, 0.8);
            color: #fff;
            border: 2px solid #fff;
            padding: 8px 16px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #game-back-button:hover {
            background-color: rgba(136, 136, 136, 1);
        }



        #stage-cleared-text {
            font-size: 3em;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .rotate-buttons {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 20;
            pointer-events: all;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .rotate-btn {
            width: 80px;
            height: 80px;
            background-color: rgba(0, 255, 255, 0.3);
            border: 2px solid #0ff;
            border-radius: 50%;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        #stage-select-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 10px;
            padding: 20px;
            max-width: 90vw;
        }

        .stage-btn {
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #f0f;
            color: #f0f;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }

        .stage-btn:hover {
            background-color: #f0f;
            color: #000;
        }

        #back-button,
        #mode-back-button {
            background-color: #888;
            color: #000;
            box-shadow: none;
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 18px;
            margin: 0;
        }

        /* ë™ë¬¼ íŒ¨í„´ ìŠ¤íƒ€ì¼ */
        .wall-block {
            position: relative;
            overflow: hidden;
        }

        .wall-block::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.8em;
            opacity: 0.3;
        }

        .wall-block.cat::before {
            content: 'ğŸ±';
        }

        .wall-block.dog::before {
            content: 'ğŸ¶';
        }

        .wall-block.bear::before {
            content: 'ğŸ»';
        }

        .wall-block.rabbit::before {
            content: 'ğŸ°';
        }

        .wall-block.fox::before {
            content: 'ğŸ¦Š';
        }

        .wall-block.panda::before {
            content: 'ğŸ¼';
        }

        @media (max-width: 768px) {
            .title {
                font-size: 3em;
            }

            #stage-select-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 15px;
            }

            .stage-btn {
                width: 55px;
                height: 55px;
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="canvas-container"></div>
        <div id="ui-layer">
            <div id="start-screen" class="screen">
                <h1 class="title">FIT THE HOLE</h1>
                <p class="subtitle">ë‹¤ê°€ì˜¤ëŠ” ë²½ì˜ êµ¬ë©ì— ë§ì¶°<br>ì´ë™í•˜ê³  íšŒì „í•˜ì—¬ í†µê³¼í•˜ì„¸ìš”!</p>
                <button id="startButton" class="button">START</button>
            </div>
            <div id="mode-select-screen" class="screen hidden">
                <button id="mode-back-button" class="button">BACK</button>
                <h2 class="title" style="font-size: 3em; margin-bottom: 30px; margin-top: 80px;">SELECT MODE</h2>
                <button id="easy-mode-btn" class="button"
                    style="margin: 20px; background-color: #00ff00; box-shadow: 0 0 15px #00ff00;">EASY MODE</button>
                <p class="subtitle" style="font-size: 1em; margin: 10px;">í•œ ë²ˆì— í•˜ë‚˜ì˜ ë²½</p>
                <button id="hard-mode-btn" class="button"
                    style="margin: 20px; background-color: #ff0000; box-shadow: 0 0 15px #ff0000;">HARD MODE</button>
                <p class="subtitle" style="font-size: 1em; margin: 10px;">ì—°ì†ìœ¼ë¡œ ë‚ ì•„ì˜¤ëŠ” ì—¬ëŸ¬ ë²½!</p>
            </div>
            <div id="stage-select-screen" class="screen hidden">
                <button id="back-button" class="button">BACK</button>
                <h2 class="title" style="font-size: 3em; margin-bottom: 20px; margin-top: 80px;">SELECT STAGE</h2>
                <div id="stage-select-grid"></div>
            </div>
            <div id="gameover-screen" class="screen hidden">
                <h1 class="title">GAME OVER</h1>
                <button id="restartButton" class="button"
                    style="background-color: #ff6b6b; box-shadow: 0 0 15px #ff6b6b;">RESTART</button>
            </div>
            <div id="win-screen" class="screen hidden">
                <h1 class="title">ALL CLEAR!</h1>
                <p class="subtitle">ëª¨ë“  ìŠ¤í…Œì´ì§€ë¥¼ í´ë¦¬ì–´í–ˆìŠµë‹ˆë‹¤!</p>
                <button id="restartButton" class="button win-restart">PLAY AGAIN</button>
            </div>
            <div id="stage-cleared-text"></div>
            <div id="hud">
                <div id="score-display">SCORE: 0</div>
                <button id="game-back-button">â† BACK</button>
                <div id="stage-display">STAGE: 1/50</div>
            </div>
        </div>
        <div class="rotate-buttons" id="rotate-buttons-container">
            <div class="rotate-btn" id="rotate-left-btn">â†¶</div>
            <div class="rotate-btn" id="rotate-right-btn">â†·</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const CUBE_SIZE = 1.5;

            // URL íŒŒë¼ë¯¸í„° íŒŒì‹±
            const urlParams = new URLSearchParams(window.location.search);
            const useTexture = urlParams.get('texture') !== 'false'; // ê¸°ë³¸ê°’: true
            const urlMode = urlParams.get('mode'); // 'easy' ë˜ëŠ” 'hard'
            const urlStage = parseInt(urlParams.get('stage')); // ìŠ¤í…Œì´ì§€ ë²ˆí˜¸ (1-50)

            console.log('URL Parameters:', { useTexture, urlMode, urlStage });
            // --- UI Elements ---
            const startScreen = document.getElementById('start-screen');
            const modeSelectScreen = document.getElementById('mode-select-screen');
            const stageSelectScreen = document.getElementById('stage-select-screen');
            const gameOverScreen = document.getElementById('gameover-screen');
            const winScreen = document.getElementById('win-screen');
            const startButton = document.getElementById('startButton');
            const easyModeBtn = document.getElementById('easy-mode-btn');
            const hardModeBtn = document.getElementById('hard-mode-btn');
            const modeBackButton = document.getElementById('mode-back-button');
            const restartButtons = document.querySelectorAll('#restartButton');
            const backButton = document.getElementById('back-button');
            const stageGrid = document.getElementById('stage-select-grid');
            const scoreDisplay = document.getElementById('score-display');
            const stageDisplay = document.getElementById('stage-display');
            const hud = document.getElementById('hud');
            const stageClearedText = document.getElementById('stage-cleared-text');
            const rotateButtonsContainer = document.getElementById('rotate-buttons-container');
            const rotateLeftBtn = document.getElementById('rotate-left-btn');
            const rotateRightBtn = document.getElementById('rotate-right-btn');
            const gameBackButton = document.getElementById('game-back-button');

            // --- Game Variables ---
            let scene, camera, renderer, player, clock, currentWall, ghostPlayer;
            let gameSpeed, score = 0, isPlaying = false, currentStage = 0;
            let gameMode = 'easy'; // 'easy' or 'hard'
            let wallQueue = []; // í•˜ë“œëª¨ë“œìš© ë²½ í
            let nextWallTimer = 0; // ë‹¤ìŒ ë²½ê¹Œì§€ì˜ ì‹œê°„
            const MOVE_AREA_RADIUS = 8;

            // ìŠ¤í…Œì´ì§€ë³„ ê³ ì • ì„¤ì • - ë‹¤ì¤‘ êµ¬ë© ì‹œìŠ¤í…œ (ì†ë„ 25 ì´í•˜ë¡œ ì œí•œ)
            const stageConfig = [
                // ê¸°ë³¸ ë‹¨ì¼ êµ¬ë© ìŠ¤í…Œì´ì§€ë“¤ (1-12) - ì†ë„ 10 ì´ìƒìœ¼ë¡œ ì¡°ì •
                { speed: 12, shape: 'L', holes: [{ shape: 'L', rotation: 0, offset: { x: 0, y: 0 } }] },
                { speed: 13, shape: 'L', holes: [{ shape: 'L', rotation: Math.PI / 2, offset: { x: 2, y: 1 } }] },
                { speed: 14, shape: 'L', holes: [{ shape: 'L', rotation: Math.PI, offset: { x: -1, y: 2 } }] },
                { speed: 15, shape: 'L', holes: [{ shape: 'L', rotation: Math.PI * 1.5, offset: { x: 1, y: -1 } }] },

                { speed: 16, shape: 'T', holes: [{ shape: 'T', rotation: 0, offset: { x: 0, y: 0 } }] },
                { speed: 17, shape: 'T', holes: [{ shape: 'T', rotation: Math.PI / 2, offset: { x: -2, y: 1 } }] },
                { speed: 18, shape: 'T', holes: [{ shape: 'T', rotation: Math.PI, offset: { x: 1, y: -2 } }] },
                { speed: 19, shape: 'T', holes: [{ shape: 'T', rotation: Math.PI * 1.5, offset: { x: 2, y: 2 } }] },

                { speed: 20, shape: 'O', holes: [{ shape: 'O', rotation: 0, offset: { x: 0, y: 0 } }] },
                { speed: 21, shape: 'O', holes: [{ shape: 'O', rotation: 0, offset: { x: -1, y: 1 } }] },
                { speed: 22, shape: 'O', holes: [{ shape: 'O', rotation: 0, offset: { x: 2, y: -1 } }] },
                { speed: 23, shape: 'O', holes: [{ shape: 'O', rotation: 0, offset: { x: -2, y: 2 } }] },

                // ë‹¤ì¤‘ êµ¬ë© ìŠ¤í…Œì´ì§€ë“¤ (13-16) - 2ê°œ êµ¬ë©
                {
                    speed: 20, shape: 'L', holes: [
                        { shape: 'L', rotation: 0, offset: { x: -3, y: 2 } },
                        { shape: 'T', rotation: Math.PI / 2, offset: { x: 3, y: -1 } }
                    ]
                },
                {
                    speed: 21, shape: 'T', holes: [
                        { shape: 'T', rotation: 0, offset: { x: 0, y: 3 } },
                        { shape: 'O', rotation: 0, offset: { x: -2, y: -2 } }
                    ]
                },
                {
                    speed: 22, shape: 'O', holes: [
                        { shape: 'O', rotation: 0, offset: { x: 2, y: 2 } },
                        { shape: 'L', rotation: Math.PI, offset: { x: -3, y: 0 } }
                    ]
                },
                {
                    speed: 23, shape: 'L', holes: [
                        { shape: 'L', rotation: Math.PI / 2, offset: { x: 1, y: 3 } },
                        { shape: 'L', rotation: Math.PI * 1.5, offset: { x: -2, y: -2 } }
                    ]
                },

                // ë” ë³µì¡í•œ ë‹¤ì¤‘ êµ¬ë© ìŠ¤í…Œì´ì§€ë“¤ (17-19) - 3ê°œ êµ¬ë©
                {
                    speed: 24, shape: 'T', holes: [
                        { shape: 'T', rotation: 0, offset: { x: 0, y: 3 } },
                        { shape: 'L', rotation: Math.PI / 2, offset: { x: -4, y: 0 } },
                        { shape: 'O', rotation: 0, offset: { x: 3, y: -2 } }
                    ]
                },
                {
                    speed: 25, shape: 'L', holes: [
                        { shape: 'L', rotation: 0, offset: { x: -3, y: 3 } },
                        { shape: 'T', rotation: Math.PI, offset: { x: 2, y: 1 } },
                        { shape: 'L', rotation: Math.PI * 1.5, offset: { x: 0, y: -3 } }
                    ]
                },
            ];

            // ë‚˜ë¨¸ì§€ ìŠ¤í…Œì´ì§€ë“¤ì„ ë³µì¡í•œ íŒ¨í„´ìœ¼ë¡œ ì±„ìš°ê¸° (ì†ë„ 25 ì´í•˜ ìœ ì§€)
            let currentSpeed = 20;
            const complexPatterns = [
                // 4ê°œ êµ¬ë© íŒ¨í„´ë“¤ - ê° íŒ¨í„´ì—ì„œ í”Œë ˆì´ì–´ ëª¨ì–‘ê³¼ ì¼ì¹˜í•˜ëŠ” êµ¬ë© ë³´ì¥
                {
                    shape: 'L', holes: [
                        { shape: 'L', rotation: 0, offset: { x: 0, y: 0 } }, // í”Œë ˆì´ì–´ì™€ ì¼ì¹˜í•˜ëŠ” êµ¬ë©
                        { shape: 'T', rotation: Math.PI / 2, offset: { x: -3, y: 2 } },
                        { shape: 'O', rotation: 0, offset: { x: 3, y: -2 } },
                        { shape: 'L', rotation: Math.PI, offset: { x: -2, y: -3 } }
                    ]
                },
                {
                    shape: 'T', holes: [
                        { shape: 'T', rotation: 0, offset: { x: 0, y: 0 } }, // í”Œë ˆì´ì–´ì™€ ì¼ì¹˜í•˜ëŠ” êµ¬ë©
                        { shape: 'L', rotation: Math.PI / 2, offset: { x: -3, y: 2 } },
                        { shape: 'O', rotation: 0, offset: { x: 3, y: -2 } },
                        { shape: 'T', rotation: Math.PI * 1.5, offset: { x: 2, y: 3 } }
                    ]
                },
                {
                    shape: 'O', holes: [
                        { shape: 'O', rotation: 0, offset: { x: 0, y: 0 } }, // í”Œë ˆì´ì–´ì™€ ì¼ì¹˜í•˜ëŠ” êµ¬ë©
                        { shape: 'L', rotation: 0, offset: { x: -3, y: 2 } },
                        { shape: 'T', rotation: Math.PI, offset: { x: 3, y: -2 } },
                        { shape: 'O', rotation: 0, offset: { x: -2, y: -3 } }
                    ]
                }
            ];

            while (stageConfig.length < 50) {
                const patternIndex = Math.max(0, stageConfig.length - 20);
                const pattern = complexPatterns[patternIndex % complexPatterns.length];

                // í”Œë ˆì´ì–´ ëª¨ì–‘ê³¼ ì¼ì¹˜í•˜ëŠ” êµ¬ë©ì´ ë°˜ë“œì‹œ í¬í•¨ë˜ë„ë¡ ìˆ˜ì •
                const newHoles = pattern.holes.map(hole => ({
                    shape: hole.shape,
                    rotation: hole.rotation + (Math.random() - 0.5) * Math.PI / 6,
                    offset: {
                        x: hole.offset.x + (Math.random() - 0.5) * 1.5,
                        y: hole.offset.y + (Math.random() - 0.5) * 1.5
                    }
                }));

                // í”Œë ˆì´ì–´ ëª¨ì–‘ê³¼ ì¼ì¹˜í•˜ëŠ” êµ¬ë©ì´ ìˆëŠ”ì§€ í™•ì¸
                const hasMatchingHole = newHoles.some(hole => hole.shape === pattern.shape);
                if (!hasMatchingHole) {
                    // ì¼ì¹˜í•˜ëŠ” êµ¬ë©ì´ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ êµ¬ë©ì„ í”Œë ˆì´ì–´ ëª¨ì–‘ìœ¼ë¡œ ë³€ê²½
                    newHoles[0].shape = pattern.shape;
                }

                stageConfig.push({
                    speed: Math.min(25, Math.round(currentSpeed)),
                    shape: pattern.shape,
                    holes: newHoles
                });
                currentSpeed += 0.5;
            }

            const shapes = {
                'I': [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 0, y: 2 }],
                'L': [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }],
                'T': [{ x: 0, y: 0 }, { x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }],
                'S': [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 1 }],
                'O': [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }],
                'PLUS': [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }],
                'U': [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 2, y: 0 }],
            };

            function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000011);
                scene.fog = new THREE.Fog(0x000011, 50, 200);
                clock = new THREE.Clock();

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 5, 15);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                const light = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(light);
                const directionalLight = new THREE.DirectionalLight(0x00ffff, 0.5);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                const hemiLight = new THREE.HemisphereLight(0x00ffff, 0xff00ff, 0.4);
                scene.add(hemiLight);

                const gridHelper = new THREE.GridHelper(400, 40, 0x00ffff, 0x00ffff);
                gridHelper.position.y = -MOVE_AREA_RADIUS - 2;
                scene.add(gridHelper);

                setupEventListeners();
                createStageSelectButtons();

                animate();
            }

            function createPlayerModel(shapeType) {
                const playerGroup = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({
                    color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.3, metalness: 0.5, roughness: 0.2
                });
                const shapeCoords = shapes[shapeType];
                const center = new THREE.Vector2();
                shapeCoords.forEach(p => center.add(new THREE.Vector2(p.x, p.y)));
                center.divideScalar(shapeCoords.length);
                shapeCoords.forEach(pos => {
                    const block = new THREE.Mesh(new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE), mat);
                    block.position.set((pos.x - center.x) * CUBE_SIZE, (pos.y - center.y) * CUBE_SIZE, 0);
                    playerGroup.add(block);
                });
                return playerGroup;
            }

            // ë™ë¬¼ í…ìŠ¤ì²˜ ìƒì„± í•¨ìˆ˜
            function createAnimalTexture(animal) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                // ë°°ê²½ìƒ‰
                ctx.fillStyle = '#ff00aa';
                ctx.fillRect(0, 0, 64, 64);

                // ë™ë¬¼ ì´ëª¨ì§€
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(animal, 32, 32);

                const texture = new THREE.CanvasTexture(canvas);
                return texture;
            }

            // ë²½ ì „ì²´ì— ë™ë¬¼ í…ìŠ¤ì²˜ë¥¼ ìƒì„±í•˜ëŠ” í•¨ìˆ˜
            function createWallAnimalTexture(animal, wallSize) {
                const canvas = document.createElement('canvas');
                const canvasSize = 512;
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const ctx = canvas.getContext('2d');

                // ë°°ê²½ìƒ‰
                ctx.fillStyle = '#ff00aa';
                ctx.fillRect(0, 0, canvasSize, canvasSize);

                // ì¤‘ì•™ì— í° ë™ë¬¼ ì´ëª¨ì§€
                ctx.font = `${canvasSize * 0.6}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(animal, canvasSize / 2, canvasSize / 2);

                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
                return texture;
            }

            function createWall(playerShape, holes, enableTexture = true) {
                const wallGroup = new THREE.Group();

                let mat, greenMat, redMat;
                let randomAnimal = '';
                const wallSize = 15;

                if (enableTexture) {
                    // ë™ë¬¼ íŒ¨í„´ ë°°ì—´
                    const animals = ['ğŸ±', 'ğŸ¶', 'ğŸ»', 'ğŸ°', 'ğŸ¦Š', 'ğŸ¼', 'ğŸ¸', 'ğŸµ', 'ğŸ¦', 'ğŸ¯'];
                    randomAnimal = animals[Math.floor(Math.random() * animals.length)];

                    const animalTexture = createWallAnimalTexture(randomAnimal, wallSize);
                    const greenTexture = createWallAnimalTexture(randomAnimal, wallSize);
                    const redTexture = createWallAnimalTexture(randomAnimal, wallSize);

                    mat = new THREE.MeshPhongMaterial({
                        color: 0xff00aa,
                        emissive: 0xff00aa,
                        emissiveIntensity: 0.3,
                        map: animalTexture
                    });

                    greenMat = new THREE.MeshPhongMaterial({
                        color: 0x00ff00,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.3,
                        map: greenTexture
                    });

                    redMat = new THREE.MeshPhongMaterial({
                        color: 0xff0000,
                        emissive: 0xff0000,
                        emissiveIntensity: 0.3,
                        map: redTexture
                    });
                } else {
                    // í…ìŠ¤ì²˜ ì—†ëŠ” ë‹¨ìˆœí•œ ìƒ‰ìƒë§Œ
                    mat = new THREE.MeshPhongMaterial({
                        color: 0xff00aa,
                        emissive: 0xff00aa,
                        emissiveIntensity: 0.3
                    });

                    greenMat = new THREE.MeshPhongMaterial({
                        color: 0x00ff00,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.3
                    });

                    redMat = new THREE.MeshPhongMaterial({
                        color: 0xff0000,
                        emissive: 0xff0000,
                        emissiveIntensity: 0.3
                    });
                }

                // ëª¨ë“  êµ¬ë© ìœ„ì¹˜ë¥¼ ê³„ì‚°
                const allHolePositions = new Set();
                const correctHolePositions = new Set(); // í”Œë ˆì´ì–´ ëª¨ì–‘ê³¼ ì¼ì¹˜í•˜ëŠ” êµ¬ë©

                holes.forEach(hole => {
                    const shapeCoords = shapes[hole.shape];
                    const center = new THREE.Vector2();
                    shapeCoords.forEach(p => center.add(new THREE.Vector2(p.x, p.y)));
                    center.divideScalar(shapeCoords.length);

                    shapeCoords.forEach(pos => {
                        let blockCenter = new THREE.Vector2((pos.x - center.x), (pos.y - center.y));
                        let rotated = blockCenter.rotateAround(new THREE.Vector2(), hole.rotation);
                        const finalX = Math.round(rotated.x + hole.offset.x);
                        const finalY = Math.round(rotated.y + hole.offset.y);
                        const posKey = `${finalX},${finalY}`;

                        allHolePositions.add(posKey);

                        // í”Œë ˆì´ì–´ ëª¨ì–‘ê³¼ ì¼ì¹˜í•˜ëŠ” êµ¬ë©ì¸ì§€ í™•ì¸
                        if (hole.shape === playerShape) {
                            correctHolePositions.add(posKey);
                        }
                    });
                });

                // ìƒ‰ìƒ ë³€ê²½ìš© í…ìŠ¤ì²˜ë“¤ ìƒì„±
                const greenTexture = createWallAnimalTexture(randomAnimal, wallSize);
                const redTexture = createWallAnimalTexture(randomAnimal, wallSize);

                // ë²½ ì •ë³´ ì €ì¥
                wallGroup.userData = {
                    allHolePositions: allHolePositions,
                    correctHolePositions: correctHolePositions,
                    holes: holes,
                    playerShape: playerShape,
                    animal: randomAnimal,
                    originalMaterial: mat,
                    greenMaterial: greenMat,
                    redMaterial: redMat
                };

                for (let x = -wallSize; x <= wallSize; x++) {
                    for (let y = -wallSize; y <= wallSize; y++) {
                        if (!allHolePositions.has(`${x},${y}`)) {
                            const blockGeo = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, 2);
                            const blockMesh = new THREE.Mesh(blockGeo, mat);
                            blockMesh.position.set(x * CUBE_SIZE, y * CUBE_SIZE, 0);

                            // í…ìŠ¤ì²˜ ì‚¬ìš© ì‹œì—ë§Œ UV ì¢Œí‘œ ì„¤ì •
                            if (enableTexture) {
                                const uvAttribute = blockMesh.geometry.attributes.uv;
                                const uvArray = uvAttribute.array;

                                // ë¸”ë¡ì˜ ì „ì²´ ë²½ì—ì„œì˜ ìƒëŒ€ì  ìœ„ì¹˜ ê³„ì‚°
                                const uStart = (x + wallSize) / (wallSize * 2);
                                const vStart = (y + wallSize) / (wallSize * 2);
                                const uSize = 1 / (wallSize * 2);
                                const vSize = 1 / (wallSize * 2);

                                // UV ì¢Œí‘œ ì—…ë°ì´íŠ¸ (ì•ë©´ê³¼ ë’·ë©´)
                                for (let i = 0; i < uvArray.length; i += 2) {
                                    const u = uvArray[i];
                                    const v = uvArray[i + 1];
                                    uvArray[i] = uStart + u * uSize;
                                    uvArray[i + 1] = vStart + v * vSize;
                                }

                                uvAttribute.needsUpdate = true;
                            }
                            wallGroup.add(blockMesh);
                        }
                    }
                }

                return wallGroup;
            }

            // í•˜ë“œëª¨ë“œìš© í•¨ìˆ˜ë“¤
            function createWallForHardMode(playerShape, holes, startZ) {
                const wall = createWall(playerShape, holes, useTexture);
                wall.position.z = startZ;
                wall.state = 'ready';
                return wall;
            }

            function spawnNextWallInQueue() {
                if (wallQueue.length === 0) return;

                const wallData = wallQueue.shift();

                // ì•ˆì „ì¥ì¹˜: í”Œë ˆì´ì–´ ëª¨ì–‘ê³¼ ì¼ì¹˜í•˜ëŠ” êµ¬ë©ì´ ìˆëŠ”ì§€ í™•ì¸
                const hasMatchingHole = wallData.holes.some(hole => hole.shape === wallData.playerShape);
                if (!hasMatchingHole) {
                    console.warn('spawnNextWallInQueue: No matching hole found! Adding one...');
                    wallData.holes.push({
                        shape: wallData.playerShape,
                        rotation: 0,
                        offset: { x: 0, y: 0 }
                    });
                }

                const wall = createWallForHardMode(wallData.playerShape, wallData.holes, -200);
                scene.add(wall);

                // í˜„ì¬ ë²½ì´ ì—†ìœ¼ë©´ ì´ ë²½ì„ í˜„ì¬ ë²½ìœ¼ë¡œ ì„¤ì •
                if (!currentWall || currentWall.state === 'passed') {
                    currentWall = wall;
                    setTimeout(() => {
                        if (isPlaying && wall.state === 'ready') wall.state = 'moving';
                    }, 1000);
                } else {
                    // ê¸°ì¡´ ë²½ì´ ìˆìœ¼ë©´ íì— ë‹¤ì‹œ ì¶”ê°€ (ë‚˜ì¤‘ì— ì²˜ë¦¬)
                    wallQueue.unshift(wallData);
                }
            }

            function setupHardModeWalls(stageIndex) {
                wallQueue = [];
                const config = stageConfig[stageIndex];

                // í•˜ë“œëª¨ë“œì—ì„œëŠ” 3-5ê°œì˜ ë²½ì„ ì—°ì†ìœ¼ë¡œ ìƒì„±
                const wallCount = Math.min(5, Math.max(3, Math.floor(stageIndex / 5) + 3));

                for (let i = 0; i < wallCount; i++) {
                    let wallHoles;

                    if (i === 0) {
                        // ì²« ë²ˆì§¸ ë²½ì€ í•­ìƒ í”Œë ˆì´ì–´ì™€ ê°™ì€ ëª¨ì–‘ì˜ êµ¬ë© í¬í•¨
                        wallHoles = config.holes;
                    } else {
                        // ë‚˜ë¨¸ì§€ ë²½ë“¤ì€ í”Œë ˆì´ì–´ ëª¨ì–‘ê³¼ ì¼ì¹˜í•˜ëŠ” êµ¬ë©ì„ ë°˜ë“œì‹œ í¬í•¨í•˜ë„ë¡ ìƒì„±
                        const randomStageIndex = Math.floor(Math.random() * Math.min(stageConfig.length, stageIndex + 5));
                        const randomConfig = stageConfig[randomStageIndex];

                        // ëœë¤ êµ¬ë©ë“¤ì„ ë³µì‚¬í•˜ë˜, í”Œë ˆì´ì–´ ëª¨ì–‘ê³¼ ì¼ì¹˜í•˜ëŠ” êµ¬ë©ì´ ì—†ìœ¼ë©´ ì¶”ê°€
                        wallHoles = [...randomConfig.holes];
                        const hasMatchingHole = wallHoles.some(hole => hole.shape === config.shape);

                        if (!hasMatchingHole) {
                            // í”Œë ˆì´ì–´ ëª¨ì–‘ê³¼ ì¼ì¹˜í•˜ëŠ” êµ¬ë©ì„ ëœë¤ ìœ„ì¹˜ì— ì¶”ê°€
                            const playerHole = {
                                shape: config.shape,
                                rotation: Math.floor(Math.random() * 4) * (Math.PI / 2),
                                offset: {
                                    x: (Math.random() - 0.5) * 6,
                                    y: (Math.random() - 0.5) * 6
                                }
                            };
                            wallHoles.push(playerHole);
                        }
                    }

                    // ë””ë²„ê¹…: íì— ì¶”ê°€ë˜ëŠ” ë²½ ë°ì´í„° í™•ì¸
                    console.log(`Wall ${i + 1} - Player: ${config.shape}, Holes: ${wallHoles.map(h => h.shape).join(', ')}`);

                    wallQueue.push({
                        playerShape: config.shape, // í•­ìƒ í˜„ì¬ ìŠ¤í…Œì´ì§€ì˜ í”Œë ˆì´ì–´ ëª¨ì–‘ ì‚¬ìš©
                        holes: wallHoles,
                        speed: config.speed
                    });
                }
            }

            function isColliding(playerObject, wallObject) {
                const wallBlocks = wallObject.children;
                for (const playerBlock of playerObject.children) {
                    const playerBox = new THREE.Box3().setFromObject(playerBlock);
                    for (const wallBlock of wallBlocks) {
                        const wallBox = new THREE.Box3().setFromObject(wallBlock);
                        if (playerBox.intersectsBox(wallBox)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function checkPlayerFitsHole(playerObject, wallObject) {
                if (!wallObject.userData) return false;

                const { allHolePositions, correctHolePositions } = wallObject.userData;
                const playerBlocks = playerObject.children;

                // í”Œë ˆì´ì–´ ë¸”ë¡ë“¤ì˜ ê·¸ë¦¬ë“œ ìœ„ì¹˜ ê³„ì‚°
                const playerGridPositions = new Set();
                playerBlocks.forEach(block => {
                    const worldPos = new THREE.Vector3();
                    block.getWorldPosition(worldPos);

                    const gridX = Math.round(worldPos.x / CUBE_SIZE);
                    const gridY = Math.round(worldPos.y / CUBE_SIZE);

                    playerGridPositions.add(`${gridX},${gridY}`);
                });

                // í”Œë ˆì´ì–´ ë¸”ë¡ë“¤ì´ ëª¨ë‘ êµ¬ë© ìœ„ì¹˜ì— ìˆëŠ”ì§€ í™•ì¸
                for (const pos of playerGridPositions) {
                    if (!allHolePositions.has(pos)) {
                        return { inHole: false, correctHole: false };
                    }
                }

                // í”Œë ˆì´ì–´ê°€ ì˜¬ë°”ë¥¸ êµ¬ë©(ê°™ì€ ëª¨ì–‘)ì— ìˆëŠ”ì§€ í™•ì¸
                let correctMatch = true;
                for (const pos of playerGridPositions) {
                    if (!correctHolePositions.has(pos)) {
                        correctMatch = false;
                        break;
                    }
                }

                return { inHole: true, correctHole: correctMatch };
            }

            function startGame(stageIndex) {
                score = 0;
                currentStage = stageIndex;
                stageSelectScreen.classList.add('hidden');
                hud.style.opacity = 1;
                rotateButtonsContainer.style.opacity = 1;
                loadStage(currentStage);
                isPlaying = true;
            }

            function loadStage(stageIndex) {
                // ê¸°ì¡´ ì˜¤ë¸Œì íŠ¸ë“¤ ì œê±°
                if (player) scene.remove(player);
                if (currentWall) scene.remove(currentWall);
                if (ghostPlayer) scene.remove(ghostPlayer);

                // í•˜ë“œëª¨ë“œì—ì„œ íì— ìˆëŠ” ë²½ë“¤ë„ ì œê±°
                wallQueue.forEach(wallData => {
                    if (wallData.wall) scene.remove(wallData.wall);
                });
                wallQueue = [];

                const config = stageConfig[stageIndex];
                gameSpeed = config.speed;

                console.log(`Stage ${stageIndex + 1}: Shape = ${config.shape}, Mode = ${gameMode}`);

                player = createPlayerModel(config.shape);
                player.position.z = 0;
                scene.add(player);

                camera.position.set(0, 5, 15);
                camera.lookAt(0, 0, 0);

                ghostPlayer = player.clone();
                ghostPlayer.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.3 });
                    }
                });
                scene.add(ghostPlayer);

                if (gameMode === 'easy') {
                    // ì´ì§€ëª¨ë“œ: ê¸°ì¡´ê³¼ ë™ì¼
                    currentWall = createWall(config.shape, config.holes, useTexture);
                    currentWall.position.z = -200;
                    scene.add(currentWall);
                    currentWall.state = 'ready';

                    setTimeout(() => {
                        if (isPlaying) currentWall.state = 'moving';
                    }, 2500);
                } else {
                    // í•˜ë“œëª¨ë“œ: ì—¬ëŸ¬ ë²½ ì„¤ì •
                    setupHardModeWalls(stageIndex);
                    nextWallTimer = 0;

                    // ì²« ë²ˆì§¸ ë²½ ì¦‰ì‹œ ìƒì„±
                    spawnNextWallInQueue();
                }

                updateUI();
            }

            function nextStage() {
                score += 100 * (currentStage + 1);
                currentStage++;
                showStageCleared(`STAGE ${currentStage + 1} CLEAR!`);
                if (currentStage >= stageConfig.length) {
                    winGame(); return;
                }
                setTimeout(() => { if (isPlaying) loadStage(currentStage); }, 2000);
            }

            function endGame(isWin = false) {
                isPlaying = false;
                if (ghostPlayer) ghostPlayer.visible = false;
                if (player) player.visible = false;
                if (currentWall) currentWall.visible = false;

                if (isWin) winScreen.classList.remove('hidden');
                else gameOverScreen.classList.remove('hidden');
                hud.style.opacity = 0;
                rotateButtonsContainer.style.opacity = 0;
            }

            function winGame() { endGame(true); }

            function animate() {
                const delta = clock.getDelta();

                if (isPlaying) {
                    // í•˜ë“œëª¨ë“œì—ì„œ ë‹¤ìŒ ë²½ íƒ€ì´ë¨¸ ì²˜ë¦¬
                    if (gameMode === 'hard') {
                        nextWallTimer += delta;

                        // í˜„ì¬ ë²½ì´ ì–´ëŠ ì •ë„ ì§€ë‚˜ê°”ê³ , íì— ë²½ì´ ë‚¨ì•„ìˆìœ¼ë©´ ë‹¤ìŒ ë²½ ìƒì„±
                        if (currentWall && currentWall.position.z > -100 && wallQueue.length > 0 && nextWallTimer > 2) {
                            spawnNextWallInQueue();
                            nextWallTimer = 0;
                        }
                    }

                    if (currentWall && currentWall.state === 'moving') {
                        currentWall.position.z += gameSpeed * delta;
                    }

                    if (ghostPlayer && currentWall) {
                        ghostPlayer.position.x = player.position.x;
                        ghostPlayer.position.y = player.position.y;
                        ghostPlayer.position.z = currentWall.position.z;
                        ghostPlayer.rotation.z = player.rotation.z;

                        // ê·¸ë¦¼ìê°€ êµ¬ë©ì— ë§ëŠ”ì§€ í™•ì¸í•˜ê³  ë²½ ìƒ‰ìƒ ë³€ê²½
                        const holeCheck = checkPlayerFitsHole(ghostPlayer, currentWall);
                        if (holeCheck.inHole) {
                            if (holeCheck.correctHole) {
                                // ì˜¬ë°”ë¥¸ êµ¬ë©ì— ë§ìœ¼ë©´ ì´ˆë¡ìƒ‰
                                currentWall.children.forEach(block => {
                                    block.material = currentWall.userData.greenMaterial;
                                });
                            } else {
                                // ì˜ëª»ëœ êµ¬ë©ì— ë§ìœ¼ë©´ ë¹¨ê°„ìƒ‰
                                currentWall.children.forEach(block => {
                                    block.material = currentWall.userData.redMaterial;
                                });
                            }
                        } else {
                            // êµ¬ë©ì— ë§ì§€ ì•Šìœ¼ë©´ ì›ë˜ ìƒ‰ìƒ
                            currentWall.children.forEach(block => {
                                block.material = currentWall.userData.originalMaterial;
                            });
                        }
                    }

                    scene.updateMatrixWorld();

                    if (currentWall) {
                        const wallZ = currentWall.position.z;
                        if (wallZ < player.position.z + 1.5 && wallZ > player.position.z - 1.5 && currentWall.state !== 'passed') {
                            // í”Œë ˆì´ì–´ê°€ ì˜¬ë°”ë¥¸ êµ¬ë©ì— ë§ëŠ”ì§€ ë¨¼ì € í™•ì¸
                            const playerHoleCheck = checkPlayerFitsHole(player, currentWall);
                            if (!(playerHoleCheck.inHole && playerHoleCheck.correctHole) && isColliding(player, currentWall)) {
                                endGame();
                            }
                        } else if (wallZ > camera.position.z && currentWall.state !== 'passed') {
                            currentWall.state = 'passed';
                            scene.remove(currentWall);

                            if (gameMode === 'hard' && wallQueue.length > 0) {
                                // í•˜ë“œëª¨ë“œì—ì„œ íì— ë²½ì´ ë‚¨ì•„ìˆìœ¼ë©´ ë‹¤ìŒ ë²½ìœ¼ë¡œ ì „í™˜
                                const nextWallData = wallQueue.shift();

                                // ë””ë²„ê¹…: ë²½ ë°ì´í„° í™•ì¸
                                console.log('Next wall data:', nextWallData);
                                console.log('Player shape:', nextWallData.playerShape);
                                console.log('Holes:', nextWallData.holes.map(h => h.shape));

                                // í”Œë ˆì´ì–´ ëª¨ì–‘ê³¼ ì¼ì¹˜í•˜ëŠ” êµ¬ë©ì´ ìˆëŠ”ì§€ í™•ì¸
                                const hasMatchingHole = nextWallData.holes.some(hole => hole.shape === nextWallData.playerShape);
                                if (!hasMatchingHole) {
                                    console.warn('No matching hole found! Adding one...');
                                    // ì¼ì¹˜í•˜ëŠ” êµ¬ë© ì¶”ê°€
                                    nextWallData.holes.push({
                                        shape: nextWallData.playerShape,
                                        rotation: 0,
                                        offset: { x: 0, y: 0 }
                                    });
                                }

                                currentWall = createWallForHardMode(nextWallData.playerShape, nextWallData.holes, -200);
                                scene.add(currentWall);
                                setTimeout(() => {
                                    if (isPlaying && currentWall.state === 'ready') currentWall.state = 'moving';
                                }, 1000);
                            } else if (gameMode === 'easy' || wallQueue.length === 0) {
                                // ì´ì§€ëª¨ë“œì´ê±°ë‚˜ í•˜ë“œëª¨ë“œì—ì„œ ëª¨ë“  ë²½ì„ í†µê³¼í–ˆìœ¼ë©´ ë‹¤ìŒ ìŠ¤í…Œì´ì§€
                                nextStage();
                            }
                        }
                    }
                }

                // ë™ë¬¼ ì˜¤ë²„ë ˆì´ ì—…ë°ì´íŠ¸
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }

            function updateUI() {
                scoreDisplay.textContent = `SCORE: ${score}`;
                const modeText = gameMode === 'hard' ? ' (HARD)' : ' (EASY)';
                stageDisplay.textContent = `STAGE: ${currentStage + 1}/${stageConfig.length}${modeText}`;
            }



            function showStageCleared(text) {
                stageClearedText.textContent = text;
                stageClearedText.style.opacity = 1;
                setTimeout(() => { stageClearedText.style.opacity = 0; }, 1500);
            }

            function createStageSelectButtons() {
                for (let i = 0; i < stageConfig.length; i++) {
                    const btn = document.createElement('button');
                    btn.textContent = i + 1;
                    btn.className = 'stage-btn';
                    btn.addEventListener('click', () => startGame(i));
                    stageGrid.appendChild(btn);
                }
            }

            function setupEventListeners() {
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                document.addEventListener('keydown', onKeyDown);
                rotateLeftBtn.addEventListener('click', () => rotatePlayer(-1));
                rotateRightBtn.addEventListener('click', () => rotatePlayer(1));
                startButton.addEventListener('click', () => {
                    startScreen.classList.add('hidden');
                    modeSelectScreen.classList.remove('hidden');
                });

                easyModeBtn.addEventListener('click', () => {
                    gameMode = 'easy';
                    modeSelectScreen.classList.add('hidden');
                    stageSelectScreen.classList.remove('hidden');
                });

                hardModeBtn.addEventListener('click', () => {
                    gameMode = 'hard';
                    modeSelectScreen.classList.add('hidden');
                    stageSelectScreen.classList.remove('hidden');
                });

                modeBackButton.addEventListener('click', () => {
                    modeSelectScreen.classList.add('hidden');
                    startScreen.classList.remove('hidden');
                });

                backButton.addEventListener('click', () => {
                    stageSelectScreen.classList.add('hidden');
                    modeSelectScreen.classList.remove('hidden');
                });

                gameBackButton.addEventListener('click', () => {
                    // ê²Œì„ ì¤‘ë‹¨í•˜ê³  ëª¨ë“œ ì„ íƒìœ¼ë¡œ ëŒì•„ê°€ê¸°
                    isPlaying = false;
                    if (currentWall) scene.remove(currentWall);
                    if (player) scene.remove(player);
                    if (ghostPlayer) scene.remove(ghostPlayer);
                    wallQueue.forEach(wallData => {
                        if (wallData.wall) scene.remove(wallData.wall);
                    });
                    wallQueue = [];

                    hud.style.opacity = 0;
                    rotateButtonsContainer.style.opacity = 0;
                    modeSelectScreen.classList.remove('hidden');
                });

                restartButtons.forEach(btn => btn.addEventListener('click', () => {
                    gameOverScreen.classList.add('hidden');
                    winScreen.classList.add('hidden');
                    modeSelectScreen.classList.remove('hidden');
                }));
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            function movePlayer(clientX, clientY) {
                if (!isPlaying) return;
                const rect = renderer.domElement.getBoundingClientRect();
                const targetX = ((clientX - rect.left) / rect.width) * 2 - 1;
                const targetY = -((clientY - rect.top) / rect.height) * 2 + 1;
                player.position.x = THREE.MathUtils.lerp(player.position.x, targetX * MOVE_AREA_RADIUS, 0.1);
                player.position.y = THREE.MathUtils.lerp(player.position.y, targetY * MOVE_AREA_RADIUS, 0.1);
            }
            function rotatePlayer(direction) {
                if (!isPlaying) return;
                player.rotation.z += (Math.PI / 2) * direction;
            }
            function onMouseMove(event) { if (isPlaying) movePlayer(event.clientX, event.clientY); }
            function onTouchMove(event) {
                event.preventDefault();
                if (isPlaying && event.touches.length > 0) {
                    movePlayer(event.touches[0].clientX, event.touches[0].clientY);
                }
            }
            function onKeyDown(event) {
                if (!isPlaying) return;
                const moveStep = 1.0;
                if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') player.position.x = Math.max(-MOVE_AREA_RADIUS, player.position.x - moveStep);
                if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') player.position.x = Math.min(MOVE_AREA_RADIUS, player.position.x + moveStep);
                if (event.key === 'ArrowUp' || event.key.toLowerCase() === 'w') player.position.y = Math.min(MOVE_AREA_RADIUS, player.position.y + moveStep);
                if (event.key === 'ArrowDown' || event.key.toLowerCase() === 's') player.position.y = Math.max(-MOVE_AREA_RADIUS, player.position.y - moveStep);
                if (event.key.toLowerCase() === 'q') rotatePlayer(-1);
                if (event.key.toLowerCase() === 'e') rotatePlayer(1);
            }

            init();

            // URL íŒŒë¼ë¯¸í„°ì— ë”°ë¥¸ ìë™ ì‹œì‘
            if (urlMode && urlStage && urlStage >= 1 && urlStage <= 50) {
                // ëª¨ë“œì™€ ìŠ¤í…Œì´ì§€ê°€ ì§€ì •ëœ ê²½ìš° ìë™ìœ¼ë¡œ ê²Œì„ ì‹œì‘
                gameMode = urlMode;
                setTimeout(() => {
                    startGame(urlStage - 1); // ìŠ¤í…Œì´ì§€ëŠ” 0ë¶€í„° ì‹œì‘í•˜ë¯€ë¡œ -1
                }, 1000);
            } else if (urlMode) {
                // ëª¨ë“œë§Œ ì§€ì •ëœ ê²½ìš° ìŠ¤í…Œì´ì§€ ì„ íƒ í™”ë©´ìœ¼ë¡œ
                gameMode = urlMode;
                setTimeout(() => {
                    startScreen.classList.add('hidden');
                    stageSelectScreen.classList.remove('hidden');
                }, 500);
            }
        });
    </script>
</body>

</html>
