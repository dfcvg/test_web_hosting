<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>핏 더 홀</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Consolas', 'Monaco', monospace;
        }
        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: none;
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        .screen {
            pointer-events: all;
            background-color: rgba(0,0,0,0.7);
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: absolute;
            transition: opacity 0.5s;
            overflow-y: auto;
        }
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
        .title {
            font-size: 4em;
            color: #0ff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #0ff;
        }
        .subtitle {
            font-size: 1.2em;
            margin-top: 20px;
            color: #f0f;
            text-shadow: 0 0 5px #f0f;
            line-height: 1.5;
        }
        .button {
            margin-top: 40px;
            padding: 15px 30px;
            font-size: 24px;
            font-weight: bold;
            color: #000;
            background-color: #0ff;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 15px #0ff, 0 0 25px #0ff;
        }
        .button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px #0ff, 0 0 40px #0ff;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            font-size: 2em;
            color: #fff;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #stage-cleared-text {
            font-size: 3em;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .rotate-buttons {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 20;
            pointer-events: all;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .rotate-btn {
            width: 80px;
            height: 80px;
            background-color: rgba(0, 255, 255, 0.3);
            border: 2px solid #0ff;
            border-radius: 50%;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }
        #stage-select-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 10px;
            padding: 20px;
            max-width: 90vw;
        }
        .stage-btn {
            width: 50px;
            height: 50px;
            background-color: rgba(0,0,0,0.5);
            border: 2px solid #f0f;
            color: #f0f;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }
        .stage-btn:hover {
            background-color: #f0f;
            color: #000;
        }
        #back-button {
            background-color: #888;
            color: #000;
            box-shadow: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="canvas-container"></div>
        <div id="ui-layer">
            <div id="start-screen" class="screen">
                <h1 class="title">FIT THE HOLE</h1>
                <p class="subtitle">다가오는 벽의 구멍에 맞춰<br>이동하고 회전하여 통과하세요!</p>
                <button id="startButton" class="button">START</button>
            </div>
            <div id="stage-select-screen" class="screen hidden">
                <h2 class="title" style="font-size: 3em; margin-bottom: 20px;">SELECT STAGE</h2>
                <div id="stage-select-grid"></div>
                <button id="back-button" class="button">BACK</button>
            </div>
            <div id="gameover-screen" class="screen hidden">
                <h1 class="title">GAME OVER</h1>
                <button id="restartButton" class="button" style="background-color: #ff6b6b; box-shadow: 0 0 15px #ff6b6b;">RESTART</button>
            </div>
            <div id="win-screen" class="screen hidden">
                <h1 class="title">ALL CLEAR!</h1>
                <p class="subtitle">모든 스테이지를 클리어했습니다!</p>
                <button id="restartButton" class="button win-restart">PLAY AGAIN</button>
            </div>
             <div id="stage-cleared-text"></div>
            <div id="hud">
                <div id="score-display">SCORE: 0</div>
                <div id="stage-display">STAGE: 1/50</div>
            </div>
        </div>
        <div class="rotate-buttons" id="rotate-buttons-container">
            <div class="rotate-btn" id="rotate-left-btn">↶</div>
            <div class="rotate-btn" id="rotate-right-btn">↷</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const CUBE_SIZE = 1.5;
        // --- UI Elements ---
        const startScreen = document.getElementById('start-screen');
        const stageSelectScreen = document.getElementById('stage-select-screen');
        const gameOverScreen = document.getElementById('gameover-screen');
        const winScreen = document.getElementById('win-screen');
        const startButton = document.getElementById('startButton');
        const restartButtons = document.querySelectorAll('#restartButton');
        const backButton = document.getElementById('back-button');
        const stageGrid = document.getElementById('stage-select-grid');
        const scoreDisplay = document.getElementById('score-display');
        const stageDisplay = document.getElementById('stage-display');
        const hud = document.getElementById('hud');
        const stageClearedText = document.getElementById('stage-cleared-text');
        const rotateButtonsContainer = document.getElementById('rotate-buttons-container');
        const rotateLeftBtn = document.getElementById('rotate-left-btn');
        const rotateRightBtn = document.getElementById('rotate-right-btn');
        
        // --- Game Variables ---
        let scene, camera, renderer, player, clock, currentWall, ghostPlayer;
        let gameSpeed, score = 0, isPlaying = false, currentStage = 0;
        const MOVE_AREA_RADIUS = 8;
        
        const stageConfig = [];
        const availableShapes = ['I', 'L', 'T', 'S', 'O', 'U', 'PLUS'];
        let currentSpeed = 20;
        for (let i = 0; i < 50; i++) {
            let shape;
            if (i < 10) shape = availableShapes[i % 2]; // I, L
            else if (i < 20) shape = availableShapes[2 + (i % 3)]; // T, S, O
            else if (i < 30) shape = availableShapes[3 + (i % 3)]; // S, O, U
            else if (i < 40) shape = availableShapes[4 + (i % 3)]; // O, U, PLUS
            else shape = availableShapes[i % availableShapes.length]; // All shapes

            stageConfig.push({ speed: Math.round(currentSpeed), shape: shape });
            currentSpeed += 1.2; // gradually increase speed
        }


        const shapes = {
            'I': [{x:0,y:0},{x:0,y:1},{x:0,y:2}],
            'L': [{x:0,y:0},{x:0,y:1},{x:1,y:1}],
            'T': [{x:0,y:0},{x:-1,y:0},{x:1,y:0},{x:0,y:1}],
            'S': [{x:0,y:0},{x:1,y:0},{x:0,y:1},{x:-1,y:1}],
            'O': [{x:0,y:0},{x:1,y:0},{x:0,y:1},{x:1,y:1}],
            'PLUS': [{x:0,y:0},{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}],
            'U': [{x:0,y:0},{x:0,y:1},{x:1,y:1},{x:2,y:1},{x:2,y:0}],
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            scene.fog = new THREE.Fog(0x000011, 50, 200);
            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const light = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(light);
            const directionalLight = new THREE.DirectionalLight(0x00ffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            const hemiLight = new THREE.HemisphereLight( 0x00ffff, 0xff00ff, 0.4 );
            scene.add(hemiLight);
            
            const gridHelper = new THREE.GridHelper(400, 40, 0x00ffff, 0x00ffff);
            gridHelper.position.y = -MOVE_AREA_RADIUS - 2;
            scene.add(gridHelper);

            setupEventListeners();
            createStageSelectButtons();
            
            animate();
        }

        function createPlayerModel(shapeType) {
            const playerGroup = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.3, metalness: 0.5, roughness: 0.2
            });
            const shapeCoords = shapes[shapeType];
            const center = new THREE.Vector2();
            shapeCoords.forEach(p => center.add(new THREE.Vector2(p.x, p.y)));
            center.divideScalar(shapeCoords.length);
            shapeCoords.forEach(pos => {
                const block = new THREE.Mesh(new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE), mat);
                block.position.set((pos.x - center.x) * CUBE_SIZE, (pos.y - center.y) * CUBE_SIZE, 0);
                playerGroup.add(block);
            });
            return playerGroup;
        }

        function createWall(shapeType) {
            const wall = new THREE.Group();
            const mat = new THREE.MeshPhongMaterial({ color: 0xff00aa, emissive: 0xff00aa, emissiveIntensity: 0.3 });
            const holeRotation = Math.floor(Math.random() * 4) * (Math.PI / 2);
            const holeOffset = new THREE.Vector2(
                (Math.random() - 0.5) * (MOVE_AREA_RADIUS * 1.5),
                (Math.random() - 0.5) * (MOVE_AREA_RADIUS * 1.5)
            );
            const holeBBox = new THREE.Box2();
            shapes[shapeType].forEach(pos => {
                 const rotatedPos = new THREE.Vector2(pos.x, pos.y).multiplyScalar(CUBE_SIZE).rotateAround(new THREE.Vector2(), holeRotation);
                 holeBBox.expandByPoint(rotatedPos);
            });
            const boundingSize = 40;
            const holeSizeMultiplier = Math.max(1.2, 4.0 - currentStage * 0.06); // Adjusted for 50 stages
            const holeWidth = ((holeBBox.max.x - holeBBox.min.x) + CUBE_SIZE) * holeSizeMultiplier;
            const holeHeight = ((holeBBox.max.y - holeBBox.min.y) + CUBE_SIZE) * holeSizeMultiplier;
            const segments = [
                { x: holeOffset.x, y: holeOffset.y + holeHeight/2 + boundingSize/2, w: boundingSize*2.5, h: boundingSize },
                { x: holeOffset.x, y: holeOffset.y - holeHeight/2 - boundingSize/2, w: boundingSize*2.5, h: boundingSize },
                { x: holeOffset.x - holeWidth/2 - boundingSize/2, y: holeOffset.y, w: boundingSize, h: holeHeight*1.2 },
                { x: holeOffset.x + holeWidth/2 + boundingSize/2, y: holeOffset.y, w: boundingSize, h: holeHeight*1.2 },
            ];
            segments.forEach(seg => {
                const geo = new THREE.BoxGeometry(seg.w, seg.h, 2);
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(seg.x, seg.y, 0);
                wall.add(mesh);
            });
            return wall;
        }

        function startGame(stageIndex) {
            score = 0;
            currentStage = stageIndex;
            stageSelectScreen.classList.add('hidden');
            hud.style.opacity = 1;
            rotateButtonsContainer.style.opacity = 1;
            loadStage(currentStage);
            isPlaying = true;
        }

        function loadStage(stageIndex) {
            if (player) scene.remove(player);
            if (currentWall) scene.remove(currentWall);
            if (ghostPlayer) scene.remove(ghostPlayer);

            const config = stageConfig[stageIndex];
            gameSpeed = config.speed;
            
            player = createPlayerModel(config.shape);
            player.position.z = 0;
            scene.add(player);
            
            camera.position.set(0, 5, 15);
            camera.lookAt(0, 0, 0);
            
            ghostPlayer = player.clone();
            ghostPlayer.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.3 });
                }
            });
            scene.add(ghostPlayer);
            
            currentWall = createWall(config.shape);
            currentWall.position.z = -120;
            scene.add(currentWall);

            updateUI();
            currentWall.state = 'ready';

            setTimeout(() => {
                if (isPlaying) currentWall.state = 'moving';
            }, 2500);
        }
        
        function nextStage() {
            score += 100 * (currentStage + 1);
            currentStage++;
            showStageCleared(`STAGE ${currentStage + 1} CLEAR!`);
            if (currentStage >= stageConfig.length) {
                winGame(); return;
            }
            setTimeout(() => { if(isPlaying) loadStage(currentStage); }, 1500);
        }

        function endGame(isWin = false) {
            isPlaying = false;
            if(ghostPlayer) ghostPlayer.visible = false;
            if(player) player.visible = false;
            if(currentWall) currentWall.visible = false;

            if (isWin) winScreen.classList.remove('hidden');
            else gameOverScreen.classList.remove('hidden');
            hud.style.opacity = 0;
            rotateButtonsContainer.style.opacity = 0;
        }
        
        function winGame() { endGame(true); }

        function animate() {
            const delta = clock.getDelta();

            if (isPlaying) {
                if (currentWall && currentWall.state === 'moving') {
                    currentWall.position.z += gameSpeed * delta;
                }

                if(ghostPlayer && currentWall) {
                    ghostPlayer.position.x = player.position.x;
                    ghostPlayer.position.y = player.position.y;
                    ghostPlayer.position.z = currentWall.position.z;
                    ghostPlayer.rotation.z = player.rotation.z;
                }

                scene.updateMatrixWorld();
                
                if (currentWall) {
                    const wallZ = currentWall.position.z;
                    if (wallZ < player.position.z + 1.5 && wallZ > player.position.z - 1.5 && currentWall.state !== 'passed') {
                        let collision = false;
                        const wallPanels = currentWall.children;
                        for (const playerBlock of player.children) {
                            const playerBox = new THREE.Box3().setFromObject(playerBlock);
                            for (const panel of wallPanels) {
                                const panelBox = new THREE.Box3().setFromObject(panel);
                                if (playerBox.intersectsBox(panelBox)) {
                                    collision = true; break;
                                }
                            }
                            if (collision) break;
                        }
                        if (collision) { endGame(); }
                    } else if (wallZ > player.position.z + 1.5 && currentWall.state !== 'passed') {
                        currentWall.state = 'passed';
                        nextStage();
                    }
                }
            }

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
        
        function updateUI() {
            scoreDisplay.textContent = `SCORE: ${score}`;
            stageDisplay.textContent = `STAGE: ${currentStage + 1}/${stageConfig.length}`;
        }

        function showStageCleared(text) {
            stageClearedText.textContent = text;
            stageClearedText.style.opacity = 1;
            setTimeout(() => { stageClearedText.style.opacity = 0; }, 1000);
        }
        
        function createStageSelectButtons() {
            for (let i = 0; i < stageConfig.length; i++) {
                const btn = document.createElement('button');
                btn.textContent = i + 1;
                btn.className = 'stage-btn';
                btn.addEventListener('click', () => startGame(i));
                stageGrid.appendChild(btn);
            }
        }

        function setupEventListeners() {
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('keydown', onKeyDown);
            rotateLeftBtn.addEventListener('click', () => rotatePlayer(-1));
            rotateRightBtn.addEventListener('click', () => rotatePlayer(1));
            startButton.addEventListener('click', () => {
                startScreen.classList.add('hidden');
                stageSelectScreen.classList.remove('hidden');
            });
            backButton.addEventListener('click', () => {
                stageSelectScreen.classList.add('hidden');
                startScreen.classList.remove('hidden');
            });
            restartButtons.forEach(btn => btn.addEventListener('click', () => {
                gameOverScreen.classList.add('hidden');
                winScreen.classList.add('hidden');
                stageSelectScreen.classList.remove('hidden');
            }));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function movePlayer(clientX, clientY) {
            if(!isPlaying) return;
            const rect = renderer.domElement.getBoundingClientRect();
            const targetX = ((clientX - rect.left) / rect.width) * 2 - 1;
            const targetY = -((clientY - rect.top) / rect.height) * 2 + 1;
            player.position.x = THREE.MathUtils.lerp(player.position.x, targetX * MOVE_AREA_RADIUS, 0.1);
            player.position.y = THREE.MathUtils.lerp(player.position.y, targetY * MOVE_AREA_RADIUS, 0.1);
        }
        function rotatePlayer(direction) {
            if(!isPlaying) return;
            player.rotation.z += (Math.PI / 2) * direction;
        }
        function onMouseMove(event) { if(isPlaying) movePlayer(event.clientX, event.clientY); }
        function onTouchMove(event) {
            event.preventDefault();
            if (isPlaying && event.touches.length > 0) {
                movePlayer(event.touches[0].clientX, event.touches[0].clientY);
            }
        }
        function onKeyDown(event) {
            if(!isPlaying) return;
            const moveStep = 1.0;
            if(event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') player.position.x = Math.max(-MOVE_AREA_RADIUS, player.position.x - moveStep);
            if(event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') player.position.x = Math.min(MOVE_AREA_RADIUS, player.position.x + moveStep);
            if(event.key === 'ArrowUp' || event.key.toLowerCase() === 'w') player.position.y = Math.min(MOVE_AREA_RADIUS, player.position.y + moveStep);
            if(event.key === 'ArrowDown' || event.key.toLowerCase() === 's') player.position.y = Math.max(-MOVE_AREA_RADIUS, player.position.y - moveStep);
            if(event.key.toLowerCase() === 'q') rotatePlayer(-1);
            if(event.key.toLowerCase() === 'e') rotatePlayer(1);
        }

        init();
    });
    </script>
</body>
</html>

