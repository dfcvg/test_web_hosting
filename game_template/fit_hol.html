<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>핏 더 홀</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }

        .screen {
            pointer-events: all;
            background-color: rgba(0, 0, 0, 0.7);
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: absolute;
            transition: opacity 0.5s;
            overflow-y: auto;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        .title {
            font-size: 4em;
            color: #0ff;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff, 0 0 40px #0ff;
        }

        .subtitle {
            font-size: 1.2em;
            margin-top: 20px;
            color: #f0f;
            text-shadow: 0 0 5px #f0f;
            line-height: 1.5;
        }

        .button {
            margin-top: 40px;
            padding: 15px 30px;
            font-size: 24px;
            font-weight: bold;
            color: #000;
            background-color: #0ff;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            z-index: 10;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 15px #0ff, 0 0 25px #0ff;
        }

        .button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px #0ff, 0 0 40px #0ff;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            font-size: 2em;
            color: #fff;
            text-shadow: 0 0 5px #fff, 0 0 10px #fff;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #stage-cleared-text {
            font-size: 3em;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .rotate-buttons {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 20;
            pointer-events: all;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .rotate-btn {
            width: 80px;
            height: 80px;
            background-color: rgba(0, 255, 255, 0.3);
            border: 2px solid #0ff;
            border-radius: 50%;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }

        #stage-select-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 10px;
            padding: 20px;
            max-width: 90vw;
        }

        .stage-btn {
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid #f0f;
            color: #f0f;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }

        .stage-btn:hover {
            background-color: #f0f;
            color: #000;
        }

        #back-button,
        #mode-back-button {
            background-color: #888;
            color: #000;
            box-shadow: none;
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 18px;
            margin: 0;
        }

        @media (max-width: 768px) {
            .title {
                font-size: 3em;
            }

            #stage-select-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 15px;
            }

            .stage-btn {
                width: 55px;
                height: 55px;
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <div id="canvas-container"></div>
        <div id="ui-layer">
            <div id="start-screen" class="screen">
                <h1 class="title">FIT THE HOLE</h1>
                <p class="subtitle">다가오는 벽의 구멍에 맞춰<br>이동하고 회전하여 통과하세요!</p>
                <button id="startButton" class="button">START</button>
            </div>
            <div id="mode-select-screen" class="screen hidden">
                <button id="mode-back-button" class="button">BACK</button>
                <h2 class="title" style="font-size: 3em; margin-bottom: 30px; margin-top: 80px;">SELECT MODE</h2>
                <button id="easy-mode-btn" class="button"
                    style="margin: 20px; background-color: #00ff00; box-shadow: 0 0 15px #00ff00;">EASY MODE</button>
                <p class="subtitle" style="font-size: 1em; margin: 10px;">한 번에 하나의 벽</p>
                <button id="hard-mode-btn" class="button"
                    style="margin: 20px; background-color: #ff0000; box-shadow: 0 0 15px #ff0000;">HARD MODE</button>
                <p class="subtitle" style="font-size: 1em; margin: 10px;">연속으로 날아오는 여러 벽!</p>
            </div>
            <div id="stage-select-screen" class="screen hidden">
                <button id="back-button" class="button">BACK</button>
                <h2 class="title" style="font-size: 3em; margin-bottom: 20px; margin-top: 80px;">SELECT STAGE</h2>
                <div id="stage-select-grid"></div>
            </div>
            <div id="gameover-screen" class="screen hidden">
                <h1 class="title">GAME OVER</h1>
                <button id="restartButton" class="button"
                    style="background-color: #ff6b6b; box-shadow: 0 0 15px #ff6b6b;">RESTART</button>
            </div>
            <div id="win-screen" class="screen hidden">
                <h1 class="title">ALL CLEAR!</h1>
                <p class="subtitle">모든 스테이지를 클리어했습니다!</p>
                <button id="restartButton" class="button win-restart">PLAY AGAIN</button>
            </div>
            <div id="stage-cleared-text"></div>
            <div id="hud">
                <div id="score-display">SCORE: 0</div>
                <div id="stage-display">STAGE: 1/50</div>
            </div>
        </div>
        <div class="rotate-buttons" id="rotate-buttons-container">
            <div class="rotate-btn" id="rotate-left-btn">↶</div>
            <div class="rotate-btn" id="rotate-right-btn">↷</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const CUBE_SIZE = 1.5;
            // --- UI Elements ---
            const startScreen = document.getElementById('start-screen');
            const modeSelectScreen = document.getElementById('mode-select-screen');
            const stageSelectScreen = document.getElementById('stage-select-screen');
            const gameOverScreen = document.getElementById('gameover-screen');
            const winScreen = document.getElementById('win-screen');
            const startButton = document.getElementById('startButton');
            const easyModeBtn = document.getElementById('easy-mode-btn');
            const hardModeBtn = document.getElementById('hard-mode-btn');
            const modeBackButton = document.getElementById('mode-back-button');
            const restartButtons = document.querySelectorAll('#restartButton');
            const backButton = document.getElementById('back-button');
            const stageGrid = document.getElementById('stage-select-grid');
            const scoreDisplay = document.getElementById('score-display');
            const stageDisplay = document.getElementById('stage-display');
            const hud = document.getElementById('hud');
            const stageClearedText = document.getElementById('stage-cleared-text');
            const rotateButtonsContainer = document.getElementById('rotate-buttons-container');
            const rotateLeftBtn = document.getElementById('rotate-left-btn');
            const rotateRightBtn = document.getElementById('rotate-right-btn');

            // --- Game Variables ---
            let scene, camera, renderer, player, clock, currentWall, ghostPlayer;
            let gameSpeed, score = 0, isPlaying = false, currentStage = 0;
            let gameMode = 'easy'; // 'easy' or 'hard'
            let wallQueue = []; // 하드모드용 벽 큐
            let nextWallTimer = 0; // 다음 벽까지의 시간
            const MOVE_AREA_RADIUS = 8;

            // 스테이지별 고정 설정 - 다중 구멍 시스템 (속도 25 이하로 제한)
            const stageConfig = [
                // 기본 단일 구멍 스테이지들 (1-12) - 속도 10 이상으로 조정
                { speed: 12, shape: 'L', holes: [{ shape: 'L', rotation: 0, offset: { x: 0, y: 0 } }] },
                { speed: 13, shape: 'L', holes: [{ shape: 'L', rotation: Math.PI / 2, offset: { x: 2, y: 1 } }] },
                { speed: 14, shape: 'L', holes: [{ shape: 'L', rotation: Math.PI, offset: { x: -1, y: 2 } }] },
                { speed: 15, shape: 'L', holes: [{ shape: 'L', rotation: Math.PI * 1.5, offset: { x: 1, y: -1 } }] },

                { speed: 16, shape: 'T', holes: [{ shape: 'T', rotation: 0, offset: { x: 0, y: 0 } }] },
                { speed: 17, shape: 'T', holes: [{ shape: 'T', rotation: Math.PI / 2, offset: { x: -2, y: 1 } }] },
                { speed: 18, shape: 'T', holes: [{ shape: 'T', rotation: Math.PI, offset: { x: 1, y: -2 } }] },
                { speed: 19, shape: 'T', holes: [{ shape: 'T', rotation: Math.PI * 1.5, offset: { x: 2, y: 2 } }] },

                { speed: 20, shape: 'O', holes: [{ shape: 'O', rotation: 0, offset: { x: 0, y: 0 } }] },
                { speed: 21, shape: 'O', holes: [{ shape: 'O', rotation: 0, offset: { x: -1, y: 1 } }] },
                { speed: 22, shape: 'O', holes: [{ shape: 'O', rotation: 0, offset: { x: 2, y: -1 } }] },
                { speed: 23, shape: 'O', holes: [{ shape: 'O', rotation: 0, offset: { x: -2, y: 2 } }] },

                // 다중 구멍 스테이지들 (13-16) - 2개 구멍
                {
                    speed: 20, shape: 'L', holes: [
                        { shape: 'L', rotation: 0, offset: { x: -3, y: 2 } },
                        { shape: 'T', rotation: Math.PI / 2, offset: { x: 3, y: -1 } }
                    ]
                },
                {
                    speed: 21, shape: 'T', holes: [
                        { shape: 'T', rotation: 0, offset: { x: 0, y: 3 } },
                        { shape: 'O', rotation: 0, offset: { x: -2, y: -2 } }
                    ]
                },
                {
                    speed: 22, shape: 'O', holes: [
                        { shape: 'O', rotation: 0, offset: { x: 2, y: 2 } },
                        { shape: 'L', rotation: Math.PI, offset: { x: -3, y: 0 } }
                    ]
                },
                {
                    speed: 23, shape: 'L', holes: [
                        { shape: 'L', rotation: Math.PI / 2, offset: { x: 1, y: 3 } },
                        { shape: 'L', rotation: Math.PI * 1.5, offset: { x: -2, y: -2 } }
                    ]
                },

                // 더 복잡한 다중 구멍 스테이지들 (17-19) - 3개 구멍
                {
                    speed: 24, shape: 'T', holes: [
                        { shape: 'T', rotation: 0, offset: { x: 0, y: 3 } },
                        { shape: 'L', rotation: Math.PI / 2, offset: { x: -4, y: 0 } },
                        { shape: 'O', rotation: 0, offset: { x: 3, y: -2 } }
                    ]
                },
                {
                    speed: 25, shape: 'L', holes: [
                        { shape: 'L', rotation: 0, offset: { x: -3, y: 3 } },
                        { shape: 'T', rotation: Math.PI, offset: { x: 2, y: 1 } },
                        { shape: 'L', rotation: Math.PI * 1.5, offset: { x: 0, y: -3 } }
                    ]
                },
            ];

            // 나머지 스테이지들을 복잡한 패턴으로 채우기 (속도 25 이하 유지)
            let currentSpeed = 15;
            const complexPatterns = [
                // 4개 구멍 패턴들 - 각 패턴에서 플레이어 모양과 일치하는 구멍 보장
                {
                    shape: 'L', holes: [
                        { shape: 'L', rotation: 0, offset: { x: 0, y: 0 } }, // 플레이어와 일치하는 구멍
                        { shape: 'T', rotation: Math.PI / 2, offset: { x: -3, y: 2 } },
                        { shape: 'O', rotation: 0, offset: { x: 3, y: -2 } },
                        { shape: 'L', rotation: Math.PI, offset: { x: -2, y: -3 } }
                    ]
                },
                {
                    shape: 'T', holes: [
                        { shape: 'T', rotation: 0, offset: { x: 0, y: 0 } }, // 플레이어와 일치하는 구멍
                        { shape: 'L', rotation: Math.PI / 2, offset: { x: -3, y: 2 } },
                        { shape: 'O', rotation: 0, offset: { x: 3, y: -2 } },
                        { shape: 'T', rotation: Math.PI * 1.5, offset: { x: 2, y: 3 } }
                    ]
                },
                {
                    shape: 'O', holes: [
                        { shape: 'O', rotation: 0, offset: { x: 0, y: 0 } }, // 플레이어와 일치하는 구멍
                        { shape: 'L', rotation: 0, offset: { x: -3, y: 2 } },
                        { shape: 'T', rotation: Math.PI, offset: { x: 3, y: -2 } },
                        { shape: 'O', rotation: 0, offset: { x: -2, y: -3 } }
                    ]
                }
            ];

            while (stageConfig.length < 50) {
                const patternIndex = Math.max(0, stageConfig.length - 20);
                const pattern = complexPatterns[patternIndex % complexPatterns.length];

                // 플레이어 모양과 일치하는 구멍이 반드시 포함되도록 수정
                const newHoles = pattern.holes.map(hole => ({
                    shape: hole.shape,
                    rotation: hole.rotation + (Math.random() - 0.5) * Math.PI / 6,
                    offset: {
                        x: hole.offset.x + (Math.random() - 0.5) * 1.5,
                        y: hole.offset.y + (Math.random() - 0.5) * 1.5
                    }
                }));

                // 플레이어 모양과 일치하는 구멍이 있는지 확인
                const hasMatchingHole = newHoles.some(hole => hole.shape === pattern.shape);
                if (!hasMatchingHole) {
                    // 일치하는 구멍이 없으면 첫 번째 구멍을 플레이어 모양으로 변경
                    newHoles[0].shape = pattern.shape;
                }

                stageConfig.push({
                    speed: Math.min(25, Math.round(currentSpeed)),
                    shape: pattern.shape,
                    holes: newHoles
                });
                currentSpeed += 0.5;
            }

            const shapes = {
                'I': [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 0, y: 2 }],
                'L': [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }],
                'T': [{ x: 0, y: 0 }, { x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }],
                'S': [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 1 }],
                'O': [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }],
                'PLUS': [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: -1, y: 0 }, { x: 0, y: 1 }, { x: 0, y: -1 }],
                'U': [{ x: 0, y: 0 }, { x: 0, y: 1 }, { x: 1, y: 1 }, { x: 2, y: 1 }, { x: 2, y: 0 }],
            };

            function init() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000011);
                scene.fog = new THREE.Fog(0x000011, 50, 200);
                clock = new THREE.Clock();

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 5, 15);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(renderer.domElement);

                const light = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(light);
                const directionalLight = new THREE.DirectionalLight(0x00ffff, 0.5);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                const hemiLight = new THREE.HemisphereLight(0x00ffff, 0xff00ff, 0.4);
                scene.add(hemiLight);

                const gridHelper = new THREE.GridHelper(400, 40, 0x00ffff, 0x00ffff);
                gridHelper.position.y = -MOVE_AREA_RADIUS - 2;
                scene.add(gridHelper);

                setupEventListeners();
                createStageSelectButtons();

                animate();
            }

            function createPlayerModel(shapeType) {
                const playerGroup = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({
                    color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 0.3, metalness: 0.5, roughness: 0.2
                });
                const shapeCoords = shapes[shapeType];
                const center = new THREE.Vector2();
                shapeCoords.forEach(p => center.add(new THREE.Vector2(p.x, p.y)));
                center.divideScalar(shapeCoords.length);
                shapeCoords.forEach(pos => {
                    const block = new THREE.Mesh(new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE), mat);
                    block.position.set((pos.x - center.x) * CUBE_SIZE, (pos.y - center.y) * CUBE_SIZE, 0);
                    playerGroup.add(block);
                });
                return playerGroup;
            }

            function createWall(playerShape, holes) {
                const wallGroup = new THREE.Group();
                const mat = new THREE.MeshPhongMaterial({ color: 0xff00aa, emissive: 0xff00aa, emissiveIntensity: 0.3 });

                // 모든 구멍 위치를 계산
                const allHolePositions = new Set();
                const correctHolePositions = new Set(); // 플레이어 모양과 일치하는 구멍

                holes.forEach(hole => {
                    const shapeCoords = shapes[hole.shape];
                    const center = new THREE.Vector2();
                    shapeCoords.forEach(p => center.add(new THREE.Vector2(p.x, p.y)));
                    center.divideScalar(shapeCoords.length);

                    shapeCoords.forEach(pos => {
                        let blockCenter = new THREE.Vector2((pos.x - center.x), (pos.y - center.y));
                        let rotated = blockCenter.rotateAround(new THREE.Vector2(), hole.rotation);
                        const finalX = Math.round(rotated.x + hole.offset.x);
                        const finalY = Math.round(rotated.y + hole.offset.y);
                        const posKey = `${finalX},${finalY}`;

                        allHolePositions.add(posKey);

                        // 플레이어 모양과 일치하는 구멍인지 확인
                        if (hole.shape === playerShape) {
                            correctHolePositions.add(posKey);
                        }
                    });
                });

                // 벽 정보 저장
                wallGroup.userData = {
                    allHolePositions: allHolePositions,
                    correctHolePositions: correctHolePositions,
                    holes: holes,
                    playerShape: playerShape,
                    originalMaterial: mat,
                    greenMaterial: new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.3 }),
                    redMaterial: new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.3 })
                };

                const wallSize = 15;
                for (let x = -wallSize; x <= wallSize; x++) {
                    for (let y = -wallSize; y <= wallSize; y++) {
                        if (!allHolePositions.has(`${x},${y}`)) {
                            const blockGeo = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, 2);
                            const blockMesh = new THREE.Mesh(blockGeo, mat);
                            blockMesh.position.set(x * CUBE_SIZE, y * CUBE_SIZE, 0);
                            wallGroup.add(blockMesh);
                        }
                    }
                }

                return wallGroup;
            }

            // 하드모드용 함수들
            function createWallForHardMode(playerShape, holes, startZ) {
                const wall = createWall(playerShape, holes);
                wall.position.z = startZ;
                wall.state = 'ready';
                return wall;
            }

            function spawnNextWallInQueue() {
                if (wallQueue.length === 0) return;

                const wallData = wallQueue.shift();

                // 안전장치: 플레이어 모양과 일치하는 구멍이 있는지 확인
                const hasMatchingHole = wallData.holes.some(hole => hole.shape === wallData.playerShape);
                if (!hasMatchingHole) {
                    console.warn('spawnNextWallInQueue: No matching hole found! Adding one...');
                    wallData.holes.push({
                        shape: wallData.playerShape,
                        rotation: 0,
                        offset: { x: 0, y: 0 }
                    });
                }

                const wall = createWallForHardMode(wallData.playerShape, wallData.holes, -200);
                scene.add(wall);

                // 현재 벽이 없으면 이 벽을 현재 벽으로 설정
                if (!currentWall || currentWall.state === 'passed') {
                    currentWall = wall;
                    setTimeout(() => {
                        if (isPlaying && wall.state === 'ready') wall.state = 'moving';
                    }, 1000);
                } else {
                    // 기존 벽이 있으면 큐에 다시 추가 (나중에 처리)
                    wallQueue.unshift(wallData);
                }
            }

            function setupHardModeWalls(stageIndex) {
                wallQueue = [];
                const config = stageConfig[stageIndex];

                // 하드모드에서는 3-5개의 벽을 연속으로 생성
                const wallCount = Math.min(5, Math.max(3, Math.floor(stageIndex / 5) + 3));

                for (let i = 0; i < wallCount; i++) {
                    let wallHoles;

                    if (i === 0) {
                        // 첫 번째 벽은 항상 플레이어와 같은 모양의 구멍 포함
                        wallHoles = config.holes;
                    } else {
                        // 나머지 벽들은 플레이어 모양과 일치하는 구멍을 반드시 포함하도록 생성
                        const randomStageIndex = Math.floor(Math.random() * Math.min(stageConfig.length, stageIndex + 5));
                        const randomConfig = stageConfig[randomStageIndex];

                        // 랜덤 구멍들을 복사하되, 플레이어 모양과 일치하는 구멍이 없으면 추가
                        wallHoles = [...randomConfig.holes];
                        const hasMatchingHole = wallHoles.some(hole => hole.shape === config.shape);

                        if (!hasMatchingHole) {
                            // 플레이어 모양과 일치하는 구멍을 랜덤 위치에 추가
                            const playerHole = {
                                shape: config.shape,
                                rotation: Math.floor(Math.random() * 4) * (Math.PI / 2),
                                offset: {
                                    x: (Math.random() - 0.5) * 6,
                                    y: (Math.random() - 0.5) * 6
                                }
                            };
                            wallHoles.push(playerHole);
                        }
                    }

                    // 디버깅: 큐에 추가되는 벽 데이터 확인
                    console.log(`Wall ${i + 1} - Player: ${config.shape}, Holes: ${wallHoles.map(h => h.shape).join(', ')}`);

                    wallQueue.push({
                        playerShape: config.shape, // 항상 현재 스테이지의 플레이어 모양 사용
                        holes: wallHoles,
                        speed: config.speed
                    });
                }
            }

            function isColliding(playerObject, wallObject) {
                const wallBlocks = wallObject.children;
                for (const playerBlock of playerObject.children) {
                    const playerBox = new THREE.Box3().setFromObject(playerBlock);
                    for (const wallBlock of wallBlocks) {
                        const wallBox = new THREE.Box3().setFromObject(wallBlock);
                        if (playerBox.intersectsBox(wallBox)) {
                            return true;
                        }
                    }
                }
                return false;
            }

            function checkPlayerFitsHole(playerObject, wallObject) {
                if (!wallObject.userData) return false;

                const { allHolePositions, correctHolePositions } = wallObject.userData;
                const playerBlocks = playerObject.children;

                // 플레이어 블록들의 그리드 위치 계산
                const playerGridPositions = new Set();
                playerBlocks.forEach(block => {
                    const worldPos = new THREE.Vector3();
                    block.getWorldPosition(worldPos);

                    const gridX = Math.round(worldPos.x / CUBE_SIZE);
                    const gridY = Math.round(worldPos.y / CUBE_SIZE);

                    playerGridPositions.add(`${gridX},${gridY}`);
                });

                // 플레이어 블록들이 모두 구멍 위치에 있는지 확인
                for (const pos of playerGridPositions) {
                    if (!allHolePositions.has(pos)) {
                        return { inHole: false, correctHole: false };
                    }
                }

                // 플레이어가 올바른 구멍(같은 모양)에 있는지 확인
                let correctMatch = true;
                for (const pos of playerGridPositions) {
                    if (!correctHolePositions.has(pos)) {
                        correctMatch = false;
                        break;
                    }
                }

                return { inHole: true, correctHole: correctMatch };
            }

            function startGame(stageIndex) {
                score = 0;
                currentStage = stageIndex;
                stageSelectScreen.classList.add('hidden');
                hud.style.opacity = 1;
                rotateButtonsContainer.style.opacity = 1;
                loadStage(currentStage);
                isPlaying = true;
            }

            function loadStage(stageIndex) {
                // 기존 오브젝트들 제거
                if (player) scene.remove(player);
                if (currentWall) scene.remove(currentWall);
                if (ghostPlayer) scene.remove(ghostPlayer);

                // 하드모드에서 큐에 있는 벽들도 제거
                wallQueue.forEach(wallData => {
                    if (wallData.wall) scene.remove(wallData.wall);
                });
                wallQueue = [];

                const config = stageConfig[stageIndex];
                gameSpeed = config.speed;

                console.log(`Stage ${stageIndex + 1}: Shape = ${config.shape}, Mode = ${gameMode}`);

                player = createPlayerModel(config.shape);
                player.position.z = 0;
                scene.add(player);

                camera.position.set(0, 5, 15);
                camera.lookAt(0, 0, 0);

                ghostPlayer = player.clone();
                ghostPlayer.traverse((child) => {
                    if (child.isMesh) {
                        child.material = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.3 });
                    }
                });
                scene.add(ghostPlayer);

                if (gameMode === 'easy') {
                    // 이지모드: 기존과 동일
                    currentWall = createWall(config.shape, config.holes);
                    currentWall.position.z = -200;
                    scene.add(currentWall);
                    currentWall.state = 'ready';

                    setTimeout(() => {
                        if (isPlaying) currentWall.state = 'moving';
                    }, 2500);
                } else {
                    // 하드모드: 여러 벽 설정
                    setupHardModeWalls(stageIndex);
                    nextWallTimer = 0;

                    // 첫 번째 벽 즉시 생성
                    spawnNextWallInQueue();
                }

                updateUI();
            }

            function nextStage() {
                score += 100 * (currentStage + 1);
                currentStage++;
                showStageCleared(`STAGE ${currentStage + 1} CLEAR!`);
                if (currentStage >= stageConfig.length) {
                    winGame(); return;
                }
                setTimeout(() => { if (isPlaying) loadStage(currentStage); }, 2000);
            }

            function endGame(isWin = false) {
                isPlaying = false;
                if (ghostPlayer) ghostPlayer.visible = false;
                if (player) player.visible = false;
                if (currentWall) currentWall.visible = false;

                if (isWin) winScreen.classList.remove('hidden');
                else gameOverScreen.classList.remove('hidden');
                hud.style.opacity = 0;
                rotateButtonsContainer.style.opacity = 0;
            }

            function winGame() { endGame(true); }

            function animate() {
                const delta = clock.getDelta();

                if (isPlaying) {
                    // 하드모드에서 다음 벽 타이머 처리
                    if (gameMode === 'hard') {
                        nextWallTimer += delta;

                        // 현재 벽이 어느 정도 지나갔고, 큐에 벽이 남아있으면 다음 벽 생성
                        if (currentWall && currentWall.position.z > -100 && wallQueue.length > 0 && nextWallTimer > 2) {
                            spawnNextWallInQueue();
                            nextWallTimer = 0;
                        }
                    }

                    if (currentWall && currentWall.state === 'moving') {
                        currentWall.position.z += gameSpeed * delta;
                    }

                    if (ghostPlayer && currentWall) {
                        ghostPlayer.position.x = player.position.x;
                        ghostPlayer.position.y = player.position.y;
                        ghostPlayer.position.z = currentWall.position.z;
                        ghostPlayer.rotation.z = player.rotation.z;

                        // 그림자가 구멍에 맞는지 확인하고 벽 색상 변경
                        const holeCheck = checkPlayerFitsHole(ghostPlayer, currentWall);
                        if (holeCheck.inHole) {
                            if (holeCheck.correctHole) {
                                // 올바른 구멍에 맞으면 초록색
                                currentWall.children.forEach(block => {
                                    block.material = currentWall.userData.greenMaterial;
                                });
                            } else {
                                // 잘못된 구멍에 맞으면 빨간색
                                currentWall.children.forEach(block => {
                                    block.material = currentWall.userData.redMaterial;
                                });
                            }
                        } else {
                            // 구멍에 맞지 않으면 원래 색상
                            currentWall.children.forEach(block => {
                                block.material = currentWall.userData.originalMaterial;
                            });
                        }
                    }

                    scene.updateMatrixWorld();

                    if (currentWall) {
                        const wallZ = currentWall.position.z;
                        if (wallZ < player.position.z + 1.5 && wallZ > player.position.z - 1.5 && currentWall.state !== 'passed') {
                            // 플레이어가 올바른 구멍에 맞는지 먼저 확인
                            const playerHoleCheck = checkPlayerFitsHole(player, currentWall);
                            if (!(playerHoleCheck.inHole && playerHoleCheck.correctHole) && isColliding(player, currentWall)) {
                                endGame();
                            }
                        } else if (wallZ > camera.position.z && currentWall.state !== 'passed') {
                            currentWall.state = 'passed';
                            scene.remove(currentWall);

                            if (gameMode === 'hard' && wallQueue.length > 0) {
                                // 하드모드에서 큐에 벽이 남아있으면 다음 벽으로 전환
                                const nextWallData = wallQueue.shift();

                                // 디버깅: 벽 데이터 확인
                                console.log('Next wall data:', nextWallData);
                                console.log('Player shape:', nextWallData.playerShape);
                                console.log('Holes:', nextWallData.holes.map(h => h.shape));

                                // 플레이어 모양과 일치하는 구멍이 있는지 확인
                                const hasMatchingHole = nextWallData.holes.some(hole => hole.shape === nextWallData.playerShape);
                                if (!hasMatchingHole) {
                                    console.warn('No matching hole found! Adding one...');
                                    // 일치하는 구멍 추가
                                    nextWallData.holes.push({
                                        shape: nextWallData.playerShape,
                                        rotation: 0,
                                        offset: { x: 0, y: 0 }
                                    });
                                }

                                currentWall = createWallForHardMode(nextWallData.playerShape, nextWallData.holes, -200);
                                scene.add(currentWall);
                                setTimeout(() => {
                                    if (isPlaying && currentWall.state === 'ready') currentWall.state = 'moving';
                                }, 1000);
                            } else if (gameMode === 'easy' || wallQueue.length === 0) {
                                // 이지모드이거나 하드모드에서 모든 벽을 통과했으면 다음 스테이지
                                nextStage();
                            }
                        }
                    }
                }

                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }

            function updateUI() {
                scoreDisplay.textContent = `SCORE: ${score}`;
                const modeText = gameMode === 'hard' ? ' (HARD)' : ' (EASY)';
                stageDisplay.textContent = `STAGE: ${currentStage + 1}/${stageConfig.length}${modeText}`;
            }

            function showStageCleared(text) {
                stageClearedText.textContent = text;
                stageClearedText.style.opacity = 1;
                setTimeout(() => { stageClearedText.style.opacity = 0; }, 1500);
            }

            function createStageSelectButtons() {
                for (let i = 0; i < stageConfig.length; i++) {
                    const btn = document.createElement('button');
                    btn.textContent = i + 1;
                    btn.className = 'stage-btn';
                    btn.addEventListener('click', () => startGame(i));
                    stageGrid.appendChild(btn);
                }
            }

            function setupEventListeners() {
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('touchmove', onTouchMove, { passive: false });
                document.addEventListener('keydown', onKeyDown);
                rotateLeftBtn.addEventListener('click', () => rotatePlayer(-1));
                rotateRightBtn.addEventListener('click', () => rotatePlayer(1));
                startButton.addEventListener('click', () => {
                    startScreen.classList.add('hidden');
                    modeSelectScreen.classList.remove('hidden');
                });

                easyModeBtn.addEventListener('click', () => {
                    gameMode = 'easy';
                    modeSelectScreen.classList.add('hidden');
                    stageSelectScreen.classList.remove('hidden');
                });

                hardModeBtn.addEventListener('click', () => {
                    gameMode = 'hard';
                    modeSelectScreen.classList.add('hidden');
                    stageSelectScreen.classList.remove('hidden');
                });

                modeBackButton.addEventListener('click', () => {
                    modeSelectScreen.classList.add('hidden');
                    startScreen.classList.remove('hidden');
                });

                backButton.addEventListener('click', () => {
                    stageSelectScreen.classList.add('hidden');
                    modeSelectScreen.classList.remove('hidden');
                });

                restartButtons.forEach(btn => btn.addEventListener('click', () => {
                    gameOverScreen.classList.add('hidden');
                    winScreen.classList.add('hidden');
                    modeSelectScreen.classList.remove('hidden');
                }));
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            function movePlayer(clientX, clientY) {
                if (!isPlaying) return;
                const rect = renderer.domElement.getBoundingClientRect();
                const targetX = ((clientX - rect.left) / rect.width) * 2 - 1;
                const targetY = -((clientY - rect.top) / rect.height) * 2 + 1;
                player.position.x = THREE.MathUtils.lerp(player.position.x, targetX * MOVE_AREA_RADIUS, 0.1);
                player.position.y = THREE.MathUtils.lerp(player.position.y, targetY * MOVE_AREA_RADIUS, 0.1);
            }
            function rotatePlayer(direction) {
                if (!isPlaying) return;
                player.rotation.z += (Math.PI / 2) * direction;
            }
            function onMouseMove(event) { if (isPlaying) movePlayer(event.clientX, event.clientY); }
            function onTouchMove(event) {
                event.preventDefault();
                if (isPlaying && event.touches.length > 0) {
                    movePlayer(event.touches[0].clientX, event.touches[0].clientY);
                }
            }
            function onKeyDown(event) {
                if (!isPlaying) return;
                const moveStep = 1.0;
                if (event.key === 'ArrowLeft' || event.key.toLowerCase() === 'a') player.position.x = Math.max(-MOVE_AREA_RADIUS, player.position.x - moveStep);
                if (event.key === 'ArrowRight' || event.key.toLowerCase() === 'd') player.position.x = Math.min(MOVE_AREA_RADIUS, player.position.x + moveStep);
                if (event.key === 'ArrowUp' || event.key.toLowerCase() === 'w') player.position.y = Math.min(MOVE_AREA_RADIUS, player.position.y + moveStep);
                if (event.key === 'ArrowDown' || event.key.toLowerCase() === 's') player.position.y = Math.max(-MOVE_AREA_RADIUS, player.position.y - moveStep);
                if (event.key.toLowerCase() === 'q') rotatePlayer(-1);
                if (event.key.toLowerCase() === 'e') rotatePlayer(1);
            }

            init();
        });
    </script>
</body>

</html>
