<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>플래피 덩크 변기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body, button, h1, p, div {
            font-family: 'Jua', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            background: linear-gradient(to bottom, #4FC3F7, #0277BD);
            position: relative;
            overflow: hidden;
            display: block;
        }
        .bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            bottom: -20px;
            animation: rise 10s infinite ease-in;
        }
        @keyframes rise {
            0% { transform: translateY(0) translateX(0); opacity: 1; }
            50% { transform: translateX(10px); }
            100% { transform: translateY(-1080px) translateX(-10px); opacity: 0; }
        }
    </style>
</head>
<body class="bg-black text-black flex items-center justify-center w-screen h-screen m-0 p-0 overflow-hidden">

    <div id="game-container" class="relative w-full h-full">
        <canvas id="gameCanvas"></canvas>
        <div id="bubbles-container" class="absolute inset-0 pointer-events-none"></div>

        <div id="in-game-ui" class="absolute top-4 left-1/2 -translate-x-1/2 text-5xl font-bold text-white hidden" style="-webkit-text-stroke: 2px black;">
            <span id="score">0</span>
            <div id="timer" class="text-3xl"></div>
        </div>

        <div id="overlay" class="absolute inset-0 bg-black/50 flex flex-col items-center justify-center text-center p-4 z-10">
            <div id="main-menu">
                <h1 class="text-6xl font-extrabold text-white mb-2" style="-webkit-text-stroke: 3px #00B8D4;">플래피 덩크 변기</h1>
                <p class="text-2xl text-yellow-300 mb-8">바다 생물을 변기 안에 덩크!</p>
                <div class="flex flex-col space-y-4">
                    <button id="modeSelectButton" class="px-12 py-4 bg-blue-500 hover:bg-blue-600 text-white rounded-full text-3xl font-bold shadow-lg">게임 시작</button>
                    <button id="helpButton" class="px-10 py-3 bg-gray-600 hover:bg-gray-700 text-white rounded-full text-xl font-bold shadow-lg">게임 설명</button>
                </div>
            </div>

            <div id="mode-select" class="hidden flex-col space-y-4">
                 <h2 class="text-4xl font-bold text-white mb-6">모드 선택</h2>
                 <button data-mode="infinite" class="mode-btn px-12 py-4 bg-purple-500 hover:bg-purple-600 text-white rounded-full text-2xl font-bold shadow-md">무한 모드</button>
                 <button data-mode="timeAttack" class="mode-btn px-12 py-4 bg-teal-500 hover:bg-teal-600 text-white rounded-full text-2xl font-bold shadow-md">타임 어택 (60초)</button>
                 <button id="backToMainFromMode" class="mt-4 px-10 py-3 bg-gray-500 hover:bg-gray-600 rounded-full text-xl font-bold shadow-lg">뒤로 가기</button>
            </div>

            <div id="difficulty-select" class="hidden flex-col space-y-4">
                <h2 class="text-4xl font-bold text-white mb-6">난이도 선택</h2>
                <button data-difficulty="easy" class="difficulty-btn px-12 py-3 bg-green-500 hover:bg-green-600 rounded-full text-2xl font-bold shadow-md">이지</button>
                <button data-difficulty="normal" class="difficulty-btn px-12 py-3 bg-blue-500 hover:bg-blue-600 rounded-full text-2xl font-bold shadow-md">노말</button>
                <button data-difficulty="hard" class="difficulty-btn px-12 py-3 bg-orange-500 hover:bg-orange-600 rounded-full text-2xl font-bold shadow-md">하드</button>
                <button data-difficulty="crazy" class="difficulty-btn px-12 py-4 bg-red-600 hover:bg-red-700 rounded-full text-2xl font-bold shadow-md">크레이지</button>
                <button id="backToModeButton" class="mt-4 px-10 py-3 bg-gray-500 hover:bg-gray-600 rounded-full text-xl font-bold shadow-lg">뒤로 가기</button>
            </div>
            
            <div id="character-select" class="hidden flex-col">
                <h2 class="text-4xl font-bold text-white mb-6">캐릭터 선택</h2>
                <div id="character-grid" class="grid grid-cols-3 gap-4"></div>
                <button id="backToDifficultyButton" class="mt-8 px-10 py-3 bg-gray-500 hover:bg-gray-600 rounded-full text-xl font-bold shadow-lg">뒤로 가기</button>
            </div>

            <div id="game-over-menu" class="hidden">
                 <h2 class="text-6xl font-extrabold text-red-500 mb-4">게임 오버!</h2>
                <p class="text-3xl mb-6 text-white">점수: <span id="final-score" class="text-yellow-300">0</span></p>
                <button id="restartButton" class="mt-4 px-10 py-4 bg-blue-500 hover:bg-blue-600 rounded-full text-2xl font-bold shadow-lg">다시 시작</button>
            </div>
        </div>

        <div id="help-overlay" class="absolute inset-0 bg-black/80 hidden flex-col items-center justify-center text-center p-6 z-20">
            <h2 class="text-4xl font-bold text-yellow-300 mb-6">게임 설명</h2>
            <div class="text-left max-w-sm space-y-3 text-lg text-white">
                <p>🐠 <span class="font-bold">목표:</span> 화면을 탭해서 바다 생물을 점프시키고, 변기 안으로 골인시키세요!</p>
                <p>🕹️ <span class="font-bold">모드:</span> 무한 모드와 60초 타임 어택 모드가 있습니다.</p>
                <p>🌶️ <span class="font-bold">고난이도:</span> 하드/크레이지 모드에서는 변기가 위아래로 움직이고, 해파리( jellyfish )와 불가사리( starfish ) 방해물이 나타납니다!</p>
            </div>
            <button id="closeHelpButton" class="mt-8 px-10 py-3 bg-red-500 hover:bg-red-600 rounded-full text-xl font-bold shadow-lg">닫기</button>
        </div>
        
        <div id="orientation-warning" class="absolute inset-0 bg-black/90 hidden flex-col items-center justify-center text-center p-6 z-30">
            <h2 class="text-4xl font-bold text-yellow-300 mb-6">🔄</h2>
            <p class="text-2xl text-white">원활한 플레이를 위해 기기를 가로로 돌려주세요.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const { Engine, Render, Runner, World, Bodies, Body, Events, Composite } = Matter;

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            const overlay = document.getElementById('overlay');
            const mainMenu = document.getElementById('main-menu');
            const modeSelect = document.getElementById('mode-select');
            const difficultySelect = document.getElementById('difficulty-select');
            const characterSelect = document.getElementById('character-select');
            const characterGrid = document.getElementById('character-grid');
            const gameOverMenu = document.getElementById('game-over-menu');
            const helpOverlay = document.getElementById('help-overlay');
            const orientationWarning = document.getElementById('orientation-warning');

            const modeSelectButton = document.getElementById('modeSelectButton');
            const helpButton = document.getElementById('helpButton');
            const closeHelpButton = document.getElementById('closeHelpButton');
            const modeButtons = document.querySelectorAll('.mode-btn');
            const difficultyButtons = document.querySelectorAll('.difficulty-btn');
            const restartButton = document.getElementById('restartButton');
            const backToMainFromMode = document.getElementById('backToMainFromMode');
            const backToModeButton = document.getElementById('backToModeButton');
            const backToDifficultyButton = document.getElementById('backToDifficultyButton');

            const inGameUI = document.getElementById('in-game-ui');
            const scoreEl = document.getElementById('score');
            const timerEl = document.getElementById('timer');
            const finalScoreEl = document.getElementById('final-score');
            const bubblesContainer = document.getElementById('bubbles-container');

            let engine, runner;
            let player, toilets, obstacles, score, gameOver, frameCount, timeAttackTimer;
            let gameSettings;
            
            const CHARACTERS = ['🐠', '🐡', '🐙', '🦑', '🦀', '🦞'];
            let selectedCharacter = CHARACTERS[0];
            let selectedDifficulty = 'normal';
            let selectedMode = 'infinite';

            const DIFFICULTIES = {
                easy:   { gravity: 1.0, jump: -11, pipeSpeed: 2, interval: 150, rimWidth: 140, color: '#4ADE80' },
                normal: { gravity: 1.2, jump: -12, pipeSpeed: 2.5, interval: 120, rimWidth: 120, color: '#FFFFFF' },
                hard:   { gravity: 1.4, jump: -13, pipeSpeed: 3, interval: 100, rimWidth: 100, color: '#F97316' },
                crazy:  { gravity: 1.6, jump: -14, pipeSpeed: 3.5, interval: 80, rimWidth: 90, color: '#EF4444' }
            };
            
            function createBubbles() {
                bubblesContainer.innerHTML = '';
                for (let i = 0; i < 20; i++) {
                    const bubble = document.createElement('div');
                    const size = Math.random() * 15 + 5;
                    bubble.style.width = `${size}px`;
                    bubble.style.height = `${size}px`;
                    bubble.style.left = `${Math.random() * 100}%`;
                    bubble.style.animationDuration = `${Math.random() * 5 + 5}s`;
                    bubble.style.animationDelay = `${Math.random() * 5}s`;
                    bubble.classList.add('bubble');
                    bubblesContainer.appendChild(bubble);
                }
            }

            function resizeCanvas() {
                const container = document.getElementById('game-container');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                checkOrientation();
            }

            function checkOrientation() {
                if (window.innerHeight > window.innerWidth) {
                    orientationWarning.style.display = 'flex';
                } else {
                    orientationWarning.style.display = 'none';
                }
            }

            class Toilet {
                constructor(x, y) {
                    const rimThickness = 15;
                    const rimWidth = gameSettings.rimWidth;
                    const options = { isStatic: true, label: 'wall', restitution: 0.8, friction: 0.1 };
                    
                    this.leftRim = Bodies.circle(x - rimWidth/2, y, rimThickness, options);
                    this.rightRim = Bodies.circle(x + rimWidth/2, y, rimThickness, options);
                    this.scoreSensor = Bodies.rectangle(x, y, rimWidth-rimThickness, 5, { isStatic: true, isSensor: true, label: 'score' });
                    
                    this.body = Composite.create({ bodies: [this.leftRim, this.rightRim, this.scoreSensor] });
                    this.passed = false;
                    
                    if (selectedDifficulty === 'hard' || selectedDifficulty === 'crazy') {
                        this.verticalSpeed = (Math.random() - 0.5) * 2;
                        this.initialY = y;
                    }
                }

                draw() {
                    const leftPos = this.body.bodies[0].position;
                    const rightPos = this.body.bodies[1].position;
                    
                    ctx.beginPath();
                    ctx.ellipse((leftPos.x + rightPos.x) / 2, leftPos.y, (rightPos.x - leftPos.x) / 2 + 5, 20, 0, 0, Math.PI * 2);
                    ctx.strokeStyle = gameSettings.color;
                    ctx.lineWidth = 10;
                    ctx.stroke();
                }

                update() {
                    let verticalMove = 0;
                     if (this.verticalSpeed) {
                         verticalMove = this.verticalSpeed;
                         if (this.body.bodies[0].position.y < this.initialY - 50 || this.body.bodies[0].position.y > this.initialY + 50) {
                            this.verticalSpeed *= -1;
                         }
                    }
                    Composite.translate(this.body, { x: -gameSettings.pipeSpeed, y: verticalMove });
                    this.draw();
                }
            }
            
            class Obstacle {
                constructor(y, emoji) {
                     const options = { isStatic: true, isSensor: true, label: 'obstacle' };
                     this.speed = (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1);
                     const x = this.speed > 0 ? -30 : canvas.width + 30;
                     this.body = Bodies.circle(x, y, 20, options);
                     this.emoji = emoji;
                     this.size = 40;
                }
                draw() {
                    ctx.font = `${this.size}px serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.emoji, this.body.position.x, this.body.position.y);
                }
                update() {
                    Body.translate(this.body, { x: this.speed, y: 0 });
                    this.draw();
                }
            }

            function init() {
                gameSettings = DIFFICULTIES[selectedDifficulty];
                resizeCanvas();
                
                engine = Engine.create();
                engine.world.gravity.y = gameSettings.gravity;
                runner = Runner.create();

                const playerX = canvas.width / 4;
                player = Bodies.circle(playerX, canvas.height / 2, 25, { 
                    label: 'player', restitution: 0.3, friction: 0.05, frictionAir: 0.01,
                });
                Body.setPosition(player, { x: playerX, y: player.position.y });
                World.add(engine.world, player);

                toilets = [];
                obstacles = [];
                score = 0;
                gameOver = false;
                frameCount = 0;
                scoreEl.textContent = 0;
                
                if (selectedMode === 'timeAttack') {
                    timeAttackTimer = 60 * 1000;
                    timerEl.textContent = `남은 시간: 60.0`;
                    timerEl.style.display = 'block';
                } else {
                    timerEl.style.display = 'none';
                }
                
                overlay.classList.add('hidden');
                inGameUI.classList.remove('hidden');
                
                Events.on(engine, 'beforeUpdate', () => {
                    Body.setPosition(player, { x: playerX, y: player.position.y });
                });
                Events.on(engine, 'afterUpdate', animate);
                Events.on(engine, 'collisionStart', handleCollision);
                Runner.run(runner, engine);
            }

            function animate() {
                if (gameOver) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.save();
                ctx.translate(player.position.x, player.position.y);
                ctx.rotate(Math.min(Math.PI / 6, Math.max(-Math.PI / 6, player.velocity.y * 0.1)));
                ctx.scale(-1, 1);
                ctx.font = `50px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(selectedCharacter, 0, 0);
                ctx.restore();

                if (frameCount % gameSettings.interval === 0) {
                    const y = Math.random() * (canvas.height - 400) + 200;
                    toilets.push(new Toilet(canvas.width + 60, y));
                    World.add(engine.world, toilets[toilets.length - 1].body);
                }
                
                if ((selectedDifficulty === 'hard' || selectedDifficulty === 'crazy') && frameCount % 180 === 0) {
                     const y = Math.random() * canvas.height;
                     const emoji = Math.random() < 0.5 ? '🐳' : '🦈';
                     const newObstacle = new Obstacle(y, emoji);
                     obstacles.push(newObstacle);
                     World.add(engine.world, newObstacle.body);
                }

                toilets.forEach((toilet, i) => {
                    toilet.update();
                    if (toilet.body.bodies[0].position.x < -100) {
                        World.remove(engine.world, toilet.body);
                        toilets.splice(i, 1);
                    }
                });
                
                obstacles.forEach((obstacle, i) => {
                    obstacle.update();
                    if(obstacle.body.position.x < -50 || obstacle.body.position.x > canvas.width + 50) {
                        World.remove(engine.world, obstacle.body);
                        obstacles.splice(i,1);
                    }
                });

                if (player.position.y > canvas.height + 50 || player.position.y < -50) {
                    endGame();
                }

                if (selectedMode === 'timeAttack') {
                    timeAttackTimer -= runner.delta;
                    timerEl.textContent = `남은 시간: ${(timeAttackTimer / 1000).toFixed(1)}`;
                    if (timeAttackTimer <= 0) {
                        timerEl.textContent = `남은 시간: 0.0`;
                        endGame();
                    }
                }
                
                frameCount++;
            }
            
            function handleCollision(event) {
                event.pairs.forEach(pair => {
                    const { bodyA, bodyB } = pair;
                    const labels = [bodyA.label, bodyB.label];
                    
                    if (labels.includes('player') && labels.includes('obstacle')) {
                        endGame();
                    }
                    
                    if (labels.includes('player') && labels.includes('score')) {
                        const sensorBody = bodyA.label === 'score' ? bodyA : bodyB;
                        const parentToilet = toilets.find(t => t.scoreSensor === sensorBody);
                        if (parentToilet && !parentToilet.passed && player.velocity.y > 0) {
                            score++;
                            scoreEl.textContent = score;
                            parentToilet.passed = true;
                        }
                    }
                });
            }

            function endGame() {
                if(gameOver) return;
                gameOver = true;
                Runner.stop(runner);
                Events.off(engine, 'afterUpdate', animate);
                Events.off(engine, 'collisionStart', handleCollision);
                inGameUI.classList.add('hidden');
                overlay.classList.remove('hidden');
                gameOverMenu.classList.remove('hidden');
                finalScoreEl.textContent = score;
            }

            function handleUserAction(e) {
                e.preventDefault();
                if (!gameOver) {
                    Body.setVelocity(player, { x: 0, y: gameSettings.jump });
                    Body.setAngularVelocity(player, -0.15);
                }
            }
            
            function populateCharacterSelect() {
                characterGrid.innerHTML = '';
                CHARACTERS.forEach(char => {
                    const charButton = document.createElement('button');
                    charButton.className = 'text-6xl p-4 bg-gray-700 rounded-lg hover:bg-gray-600 transition-colors';
                    charButton.textContent = char;
                    charButton.onclick = () => {
                        selectedCharacter = char;
                        characterSelect.classList.add('hidden');
                        init();
                    };
                    characterGrid.appendChild(charButton);
                });
            }

            modeSelectButton.addEventListener('click', () => {
                mainMenu.classList.add('hidden');
                modeSelect.classList.remove('hidden');
                modeSelect.classList.add('flex');
            });

            modeButtons.forEach(button => {
                button.addEventListener('click', e => {
                    selectedMode = e.target.dataset.mode;
                    modeSelect.classList.add('hidden');
                    modeSelect.classList.remove('flex');
                    difficultySelect.classList.remove('hidden');
                    difficultySelect.classList.add('flex');
                });
            });

            difficultyButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    selectedDifficulty = e.target.dataset.difficulty;
                    difficultySelect.classList.add('hidden');
                    difficultySelect.classList.remove('flex');
                    characterSelect.classList.remove('hidden');
                    characterSelect.classList.add('flex');
                });
            });

            restartButton.addEventListener('click', () => {
                gameOverMenu.classList.add('hidden');
                mainMenu.classList.remove('hidden');
            });
            
            backToMainFromMode.addEventListener('click', () => {
                modeSelect.classList.add('hidden');
                modeSelect.classList.remove('flex');
                mainMenu.classList.remove('hidden');
            });

            backToModeButton.addEventListener('click', () => {
                difficultySelect.classList.add('hidden');
                difficultySelect.classList.remove('flex');
                modeSelect.classList.remove('hidden');
                modeSelect.classList.add('flex');
            });

            backToDifficultyButton.addEventListener('click', () => {
                characterSelect.classList.add('hidden');
                characterSelect.classList.remove('flex');
                difficultySelect.classList.remove('hidden');
                difficultySelect.classList.add('flex');
            });
            
            helpButton.addEventListener('click', () => { helpOverlay.style.display = 'flex'; });
            closeHelpButton.addEventListener('click', () => { helpOverlay.style.display = 'none'; });

            canvas.addEventListener('mousedown', handleUserAction);
            canvas.addEventListener('touchstart', handleUserAction);
            window.addEventListener('keydown', (e) => {
                if (e.code === 'Space') handleUserAction(e);
            });

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            populateCharacterSelect();
            createBubbles();
        });
    </script>
</body>
</html>

