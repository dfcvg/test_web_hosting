<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>타워 캔디 크러쉬 3D</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for a playful look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Jua', sans-serif;
            background-color: #fce4ec; /* Light pink background */
            background-image:
                radial-gradient(circle at 100% 100%, #f8bbd0 0, #fce4ec 40%),
                radial-gradient(circle at 0% 0%, #e1bee7 0, #fce4ec 50%);
            touch-action: none;
            overflow: hidden; /* Prevent scrolling */
        }
        #canvas-container {
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        .text-pop {
            animation: pop 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        .modal-overlay {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 text-gray-800">

    <!-- Start Screen -->
    <div id="start-screen" class="fixed inset-0 bg-pink-100/50 backdrop-blur-sm z-50 flex flex-col items-center justify-center p-4">
        <h1 class="text-5xl md:text-6xl font-bold text-pink-500 mb-4 text-center" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.1);">타워 캔디 크러쉬 3D</h1>
        <p class="text-xl text-pink-400 mb-8">플레이할 레벨을 선택하세요</p>
        <div id="level-select" class="grid grid-cols-2 sm:grid-cols-5 gap-4">
            <!-- Level buttons will be inserted here by JS -->
        </div>
    </div>

    <!-- Main Game UI -->
    <main id="game-ui" class="hidden flex-col items-center w-full">
        <h1 class="text-4xl md:text-5xl font-bold text-pink-500 mb-2 text-center" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.1);">타워 캔디 크러쉬 3D</h1>
        <p class="text-pink-400 mb-2 text-center">큐브를 돌려가며 같은 캔디를 3개 이상 맞춰보세요!</p>

        <div class="bg-white/70 backdrop-blur-sm p-3 rounded-xl shadow-lg w-full max-w-sm md:max-w-md flex justify-around items-center mb-3">
            <div>
                <p class="text-base text-purple-500">목표 점수</p>
                <p id="targetScore" class="text-xl font-bold text-center">1000</p>
            </div>
            <div>
                <p class="text-base text-purple-500">현재 점수</p>
                <p id="score" class="text-xl font-bold text-center">0</p>
            </div>
            <div>
                <p class="text-base text-purple-500">남은 횟수</p>
                <p id="moves" class="text-xl font-bold text-center">30</p>
            </div>
            <div id="mission-box" class="flex-col items-center hidden">
                <p class="text-base text-purple-500">미션</p>
                <div id="mission-targets" class="flex space-x-2 h-8 items-center">
                    <!-- Mission targets will be here -->
                </div>
            </div>
        </div>

        <div id="canvas-container" class="w-full max-w-xl aspect-square rounded-xl shadow-2xl">
            <!-- 3D game will be rendered here -->
        </div>
    </main>
    
    <!-- Game Over Modal -->
    <div id="modal" class="fixed inset-0 modal-overlay items-center justify-center hidden">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center max-w-sm transform transition-all duration-300 scale-95 opacity-0" id="modal-content">
            <h2 id="modal-title" class="text-3xl font-bold mb-4">게임 오버!</h2>
            <p id="modal-text" class="text-lg mb-6">아쉽지만 목표를 달성하지 못했어요.</p>
            <button id="modal-restart" class="w-full px-6 py-3 bg-pink-500 text-white font-bold rounded-full shadow-lg hover:bg-pink-600 active:scale-95 transition-transform duration-150">
                레벨 선택으로
            </button>
        </div>
    </div>
    
    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Basic Setup ---
        const scoreEl = document.getElementById('score');
        const movesEl = document.getElementById('moves');
        const targetScoreEl = document.getElementById('targetScore');
        const container = document.getElementById('canvas-container');
        const modal = document.getElementById('modal');
        const modalContent = document.getElementById('modal-content');
        const modalTitle = document.getElementById('modal-title');
        const modalText = document.getElementById('modal-text');
        const modalRestart = document.getElementById('modal-restart');
        const startScreen = document.getElementById('start-screen');
        const gameUI = document.getElementById('game-ui');
        const levelSelectContainer = document.getElementById('level-select');

        let scene, camera, renderer, controls, raycaster, mouse;
        let gameGroup; // Parent group for the cube and candies

        // --- Game Constants ---
        const GRID_SIZE = 5; // Candies per row/column on each face
        const CUBE_SIZE = 10;
        const CANDY_SIZE = CUBE_SIZE / GRID_SIZE * 0.8;
        const CANDY_TYPES = [
            { id: 0, geometry: new THREE.BoxGeometry(CANDY_SIZE, CANDY_SIZE, CANDY_SIZE), color: 0xff69b4 },
            { id: 1, geometry: new THREE.SphereGeometry(CANDY_SIZE / 2, 16, 16), color: 0x87ceeb },
            { id: 2, geometry: new THREE.ConeGeometry(CANDY_SIZE / 2, CANDY_SIZE, 16), color: 0x98fb98 },
            { id: 3, geometry: new THREE.DodecahedronGeometry(CANDY_SIZE / 2), color: 0xffd700 },
            { id: 4, geometry: new THREE.TorusGeometry(CANDY_SIZE / 2.5, CANDY_SIZE / 6, 8, 16), color: 0xdda0dd },
            { id: 5, geometry: new THREE.TorusKnotGeometry(CANDY_SIZE / 2.5, CANDY_SIZE / 8, 64, 8, 2, 3), color: 0x333333, isSpecial: true, specialType: 'bomb' }
        ];
        const REGULAR_CANDY_COUNT = 5;
        const LEVELS = [
            { score: 1000, moves: 40, mission: null },
            { score: 0, moves: 35, mission: { type: 'collect', targets: [{ typeId: 1, count: 25 }, { typeId: 3, count: 25 }] } },
            { score: 1500, moves: 30, mission: { type: 'collect', targets: [{ typeId: 0, count: 30 }, { typeId: 4, count: 30 }] } },
            { score: 0, moves: 25, mission: { type: 'collect', targets: [{ typeId: 2, count: 50 }] } },
            { score: 3000, moves: 25, mission: null }
        ];

        // --- Game State ---
        let board = [];
        let score = 0;
        let movesLeft = 30;
        let targetScore = 1000;
        let isProcessing = false;
        let selectedCandy = null;
        let currentMission = null;

        // --- Main Functions ---
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfce4ec);

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.enablePan = false;
            controls.minDistance = 12;
            controls.maxDistance = 30;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            gameGroup = new THREE.Group();
            scene.add(gameGroup);

            setupLevelButtons();
            
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            window.addEventListener('resize', onWindowResize);
            modalRestart.addEventListener('click', backToMenu);

            animate();
        }

        function setupLevelButtons() {
            LEVELS.forEach((level, index) => {
                const button = document.createElement('button');
                button.innerText = `Lv. ${index + 1}`;
                button.className = 'px-6 py-3 bg-pink-500 text-white font-bold rounded-full shadow-lg hover:bg-pink-600 active:scale-95 transition-transform duration-150 text-xl';
                button.addEventListener('click', () => startGame(index));
                levelSelectContainer.appendChild(button);
            });
        }
        
        function startGame(levelIndex) {
            const level = LEVELS[levelIndex];
            targetScore = level.score;
            movesLeft = level.moves;
            currentMission = level.mission ? JSON.parse(JSON.stringify(level.mission)) : null;

            startScreen.classList.add('hidden');
            gameUI.classList.remove('hidden');
            gameUI.classList.add('flex');
            
            onWindowResize();
            setupGame();
        }

        function setupGame() {
            score = 0;
            isProcessing = false;
            if(selectedCandy) highlightCandy(selectedCandy, false);
            selectedCandy = null;
            updateUI();
            
            do {
                while (gameGroup.children.length > 0) {
                    gameGroup.remove(gameGroup.children[0]);
                }
                
                const faceGeometry = new THREE.PlaneGeometry(CUBE_SIZE, CUBE_SIZE);
                const faceMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });

                const faces = [];
                const facePositions = [
                    { p: { z: CUBE_SIZE / 2 }, r: {} },
                    { p: { z: -CUBE_SIZE / 2 }, r: { y: Math.PI } },
                    { p: { y: CUBE_SIZE / 2 }, r: { x: -Math.PI / 2 } },
                    { p: { y: -CUBE_SIZE / 2 }, r: { x: Math.PI / 2 } },
                    { p: { x: CUBE_SIZE / 2 }, r: { y: Math.PI / 2 } },
                    { p: { x: -CUBE_SIZE / 2 }, r: { y: -Math.PI / 2 } }
                ];
                facePositions.forEach(pos => {
                    const face = new THREE.Mesh(faceGeometry, faceMaterial.clone());
                    if(pos.p.x) face.position.x = pos.p.x;
                    if(pos.p.y) face.position.y = pos.p.y;
                    if(pos.p.z) face.position.z = pos.p.z;
                    if(pos.r.x) face.rotation.x = pos.r.x;
                    if(pos.r.y) face.rotation.y = pos.r.y;
                    faces.push(face);
                });
                faces.forEach(face => gameGroup.add(face));

                board = [];
                for (let face = 0; face < 6; face++) {
                    const faceGrid = [];
                    for (let row = 0; row < GRID_SIZE; row++) {
                        const rowArray = [];
                        for (let col = 0; col < GRID_SIZE; col++) {
                            const candyTypeIndex = Math.floor(Math.random() * REGULAR_CANDY_COUNT);
                            const candy = createCandy(face, row, col, candyTypeIndex);
                            rowArray.push(candy);
                            gameGroup.add(candy.mesh);
                        }
                        faceGrid.push(rowArray);
                    }
                    board.push(faceGrid);
                }
            } while (findMatches().length > 0);
        }
        
        function createCandy(face, row, col, typeIndex) {
            const candyInfo = CANDY_TYPES[typeIndex];
            const material = new THREE.MeshStandardMaterial({ color: candyInfo.color, roughness: 0.5, metalness: 0.1 });
            const mesh = new THREE.Mesh(candyInfo.geometry, material);

            mesh.position.copy(get3DPosition(face, row, col));
            
            const baseRotation = new THREE.Quaternion();
            switch (face) {
                case 1: baseRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI); break;
                case 2: baseRotation.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2); break;
                case 3: baseRotation.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2); break;
                case 4: baseRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2); break;
                case 5: baseRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), -Math.PI / 2); break;
            }
            mesh.quaternion.copy(baseRotation);

            const candyObject = { mesh, face, row, col, typeId: candyInfo.id, isSpecial: !!candyInfo.isSpecial, specialType: candyInfo.specialType || null };
            mesh.userData = candyObject;
            return candyObject;
        }

        function get3DPosition(face, row, col) {
            const offset = -CUBE_SIZE / 2 + (CUBE_SIZE / GRID_SIZE / 2);
            const x = offset + col * (CUBE_SIZE / GRID_SIZE);
            const y = offset + (GRID_SIZE - 1 - row) * (CUBE_SIZE / GRID_SIZE);
            const z = CUBE_SIZE / 2 + 0.2;

            switch (face) {
                case 0: return new THREE.Vector3(x, y, z); // Front
                case 1: return new THREE.Vector3(-x, y, -z); // Back
                case 2: return new THREE.Vector3(x, z, -y); // Top
                case 3: return new THREE.Vector3(x, -z, y); // Bottom
                case 4: return new THREE.Vector3(z, y, -x); // Right
                case 5: return new THREE.Vector3(-z, y, x); // Left
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            if(container.clientWidth > 0 && container.clientHeight > 0){
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }

        function onPointerDown(event) {
            if (modal.classList.contains('flex') || isProcessing) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(gameGroup.children);

            let clickedCandy = null;
            for(const intersect of intersects) {
                if (intersect.object.userData.typeId !== undefined) {
                    clickedCandy = intersect.object.userData;
                    break;
                }
            }

            if (clickedCandy) {
                if (!selectedCandy) {
                    selectedCandy = clickedCandy;
                    highlightCandy(selectedCandy, true);
                } else {
                    if (areCandiesAdjacent(selectedCandy, clickedCandy)) {
                         handleSwap(selectedCandy, clickedCandy);
                    }
                    highlightCandy(selectedCandy, false);
                    selectedCandy = null;
                }
            } else {
                 if (selectedCandy) {
                    highlightCandy(selectedCandy, false);
                    selectedCandy = null;
                 }
            }
        }
        
        function highlightCandy(candy, isSelected) {
             const material = candy.mesh.material;
             if (isSelected) {
                material.emissive.setHex(0x555555);
             } else {
                material.emissive.setHex(0x000000);
             }
        }
        
        function areCandiesAdjacent(candy1, candy2) {
            if (candy1.face !== candy2.face) return false;
            const dr = Math.abs(candy1.row - candy2.row);
            const dc = Math.abs(candy1.col - candy2.col);
            return (dr === 1 && dc === 0) || (dr === 0 && dc === 1);
        }

        async function handleSwap(candy1, candy2) {
            isProcessing = true;
            
            board[candy1.face][candy1.row][candy1.col] = candy2;
            board[candy2.face][candy2.row][candy2.col] = candy1;
            [candy1.row, candy2.row, candy1.col, candy2.col] = [candy2.row, candy1.row, candy2.col, candy1.col];
            
            await Promise.all([ animateMove(candy1.mesh, get3DPosition(candy1.face, candy1.row, candy1.col)), animateMove(candy2.mesh, get3DPosition(candy2.face, candy2.row, candy2.col)) ]);
            
            const matches = findMatches();
            if (matches.length > 0) {
                 movesLeft--;
                 updateUI();
                 await processMatches(matches);
            } else {
                board[candy1.face][candy1.row][candy1.col] = candy2;
                board[candy2.face][candy2.row][candy2.col] = candy1;
                [candy1.row, candy2.row, candy1.col, candy2.col] = [candy2.row, candy1.row, candy2.col, candy1.col];
                await Promise.all([ animateMove(candy1.mesh, get3DPosition(candy1.face, candy1.row, candy1.col)), animateMove(candy2.mesh, get3DPosition(candy2.face, candy2.row, candy2.col)) ]);
                isProcessing = false;
            }
        }
        
        function findMatches() {
            const matches = new Set();
            for (let f = 0; f < 6; f++) {
                const faceGrid = board[f];
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE - 2; c++) {
                        if (faceGrid[r][c] && faceGrid[r][c+1] && faceGrid[r][c+2] && faceGrid[r][c].typeId === faceGrid[r][c+1].typeId && faceGrid[r][c+1].typeId === faceGrid[r][c+2].typeId) {
                            matches.add(faceGrid[r][c]).add(faceGrid[r][c+1]).add(faceGrid[r][c+2]);
                        }
                    }
                }
                for (let r = 0; r < GRID_SIZE - 2; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                       if (faceGrid[r][c] && faceGrid[r+1][c] && faceGrid[r+2][c] && faceGrid[r][c].typeId === faceGrid[r+1][c].typeId && faceGrid[r+1][c].typeId === faceGrid[r+2][c].typeId) {
                            matches.add(faceGrid[r][c]).add(faceGrid[r+1][c]).add(faceGrid[r+2][c]);
                        }
                    }
                }
            }
            return Array.from(matches);
        }

        async function processMatches(matches) {
            isProcessing = true;
            const candiesToDestroy = new Set(matches);

            matches.forEach(candy => {
                if (candy.isSpecial && candy.specialType === 'bomb') {
                    for (let r_off = -1; r_off <= 1; r_off++) {
                        for (let c_off = -1; c_off <= 1; c_off++) {
                            const newRow = candy.row + r_off;
                            const newCol = candy.col + c_off;
                            if (newRow >= 0 && newRow < GRID_SIZE && newCol >= 0 && newCol < GRID_SIZE) {
                                candiesToDestroy.add(board[candy.face][newRow][newCol]);
                            }
                        }
                    }
                }
            });

            const destroyedCandiesArray = Array.from(candiesToDestroy);
            score += destroyedCandiesArray.length * 10;
            if (currentMission && currentMission.type === 'collect') {
                destroyedCandiesArray.forEach(candy => {
                    if (candy && !candy.isSpecial) {
                         const missionTarget = currentMission.targets.find(t => t.typeId === candy.typeId);
                         if (missionTarget && missionTarget.count > 0) {
                             missionTarget.count--;
                         }
                    }
                });
            }
            updateUI();
            
            await Promise.all(destroyedCandiesArray.map(candy => candy ? animateVanish(candy.mesh) : Promise.resolve()));

            destroyedCandiesArray.forEach(candy => {
                if (candy && board[candy.face][candy.row][candy.col] === candy) {
                    gameGroup.remove(candy.mesh);
                    board[candy.face][candy.row][candy.col] = null;
                }
            });
            
            const facesToProcess = [...new Set(destroyedCandiesArray.map(c => c ? c.face : -1).filter(f => f !== -1))];
            await Promise.all(facesToProcess.map(face => applyGravityAndRefill(face)));
            
            const newMatches = findMatches();
            if (newMatches.length > 0) {
                await processMatches(newMatches);
            } else {
                isProcessing = false;
                checkGameOver();
            }
        }
        
        async function applyGravityAndRefill(faceIndex) {
            const faceGrid = board[faceIndex];
            const fallAnimations = [];

            for (let c = 0; c < GRID_SIZE; c++) {
                let emptyRow = -1;
                for (let r = GRID_SIZE - 1; r >= 0; r--) {
                    if (faceGrid[r][c] === null && emptyRow === -1) emptyRow = r;
                    else if (faceGrid[r][c] !== null && emptyRow !== -1) {
                        const candy = faceGrid[r][c];
                        faceGrid[emptyRow][c] = candy;
                        faceGrid[r][c] = null;
                        candy.row = emptyRow;
                        fallAnimations.push(animateMove(candy.mesh, get3DPosition(faceIndex, emptyRow, c)));
                        emptyRow--;
                    }
                }
            }
            
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (faceGrid[r][c] === null) {
                        let candyTypeIndex = Math.random() < 0.05 ? 5 : Math.floor(Math.random() * REGULAR_CANDY_COUNT);
                        const candy = createCandy(faceIndex, r, c, candyTypeIndex);
                        faceGrid[r][c] = candy;
                        gameGroup.add(candy.mesh);
                        candy.mesh.position.copy(get3DPosition(faceIndex, -2, c));
                        fallAnimations.push(animateMove(candy.mesh, get3DPosition(faceIndex, r, c), 200 + r * 50));
                    }
                }
            }
            await Promise.all(fallAnimations);
        }
        
        function checkGameOver() {
            if (isProcessing) return;
            
            let missionComplete = false;
            if (currentMission && currentMission.type === 'collect') {
                missionComplete = currentMission.targets.every(t => t.count <= 0);
            }

            if (currentMission) {
                if(missionComplete) showModal(true);
                else if (movesLeft <= 0) showModal(false);
            } else {
                if (score >= targetScore) showModal(true);
                else if (movesLeft <= 0) showModal(false);
            }
        }

        function animateMove(mesh, targetPosition, delay = 0) {
            return new Promise(resolve => {
                setTimeout(() => {
                    const startPosition = mesh.position.clone();
                    const duration = 250;
                    const startTime = performance.now();
                    function animate() {
                        const elapsedTime = performance.now() - startTime;
                        const progress = Math.min(elapsedTime / duration, 1);
                        mesh.position.lerpVectors(startPosition, targetPosition, progress);
                        if (progress < 1) requestAnimationFrame(animate);
                        else resolve();
                    }
                    animate();
                }, delay);
            });
        }
        
        function animateVanish(mesh) {
            return new Promise(resolve => {
                const startScale = mesh.scale.clone();
                const duration = 200;
                const startTime = performance.now();
                function animate() {
                    const elapsedTime = performance.now() - startTime;
                    const progress = Math.min(elapsedTime / duration, 1);
                    const scale = 1 - progress;
                    mesh.scale.set(startScale.x * scale, startScale.y * scale, startScale.z * scale);
                    if (progress < 1) requestAnimationFrame(animate);
                    else resolve();
                }
                animate();
            });
        }
        
        function updateUI() {
            if (scoreEl.textContent !== String(score)) {
                scoreEl.classList.add('text-pop');
                scoreEl.textContent = score;
                setTimeout(() => scoreEl.classList.remove('text-pop'), 500);
            }
            if (movesEl.textContent !== String(movesLeft)) {
                movesEl.classList.add('text-pop');
                movesEl.textContent = movesLeft;
                setTimeout(() => movesEl.classList.remove('text-pop'), 500);
            }
            targetScoreEl.textContent = (currentMission && targetScore === 0) ? '-' : targetScore;
            updateMissionUI();
        }

        function updateMissionUI() {
            const missionBox = document.getElementById('mission-box');
            const missionTargetsEl = document.getElementById('mission-targets');
            missionTargetsEl.innerHTML = '';

            if (currentMission && currentMission.type === 'collect') {
                missionBox.style.display = 'flex';
                currentMission.targets.forEach(target => {
                    const candyType = CANDY_TYPES.find(c => c.id === target.typeId);
                    if (!candyType) return;

                    const targetEl = document.createElement('div');
                    targetEl.className = 'flex items-center space-x-1 px-2 py-1 rounded-full bg-white/50';

                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'w-4 h-4 rounded-full border border-gray-400/50';
                    colorDiv.style.backgroundColor = `#${candyType.color.toString(16).padStart(6, '0')}`;

                    const countSpan = document.createElement('span');
                    countSpan.className = 'font-bold text-sm text-purple-700';
                    
                    if (target.count <= 0) {
                        targetEl.classList.add('opacity-50');
                        countSpan.textContent = '✓';
                    } else {
                        countSpan.textContent = target.count;
                    }

                    targetEl.appendChild(colorDiv);
                    targetEl.appendChild(countSpan);
                    missionTargetsEl.appendChild(targetEl);
                });
            } else {
                missionBox.style.display = 'none';
            }
        }

        function showModal(isWin) {
            isProcessing = true;
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            
            setTimeout(() => {
                modalContent.classList.remove('scale-95', 'opacity-0');
                modalContent.classList.add('scale-100', 'opacity-100');
            }, 50);

            if (isWin) {
                modalTitle.textContent = '🎉 성공! 🎉';
                modalTitle.style.color = '#ec4899';
                modalText.textContent = currentMission ? '축하합니다! 미션을 완료했어요!' : `축하합니다! 목표 점수 ${targetScore}점을 달성했어요!`;
            } else {
                modalTitle.textContent = '게임 오버!';
                modalTitle.style.color = '#888';
                modalText.textContent = `아쉽지만 다음 기회에! 최종 점수: ${score}점`;
            }
        }

        function hideModal() {
            modalContent.classList.add('scale-95', 'opacity-0');
            modalContent.classList.remove('scale-100', 'opacity-100');
            setTimeout(() => {
                modal.classList.add('hidden');
                modal.classList.remove('flex');
            }, 300);
        }

        function backToMenu() {
            hideModal();
            setTimeout(() => {
                gameUI.classList.add('hidden');
                gameUI.classList.remove('flex');
                startScreen.classList.remove('hidden');
            }, 300);
        }

        // --- Start ---
        init();
    </script>
</body>
</html>

