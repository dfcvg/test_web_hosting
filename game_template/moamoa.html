<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>웹게임 포털</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body, button, h1, p, span, div {
            font-family: 'Jua', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        .hidden { display: none; }
        .game-screen {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: #1a202c;
            display: flex;
            flex-direction: column;
        }
        canvas {
            background-color: #000;
            display: block;
            flex-grow: 1;
        }
        .back-button {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10;
        }
        .score-display {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10;
            font-size: 1.5rem;
            color: white;
        }
        .game-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            box-sizing: border-box;
            z-index: 10;
        }
        .control-btn {
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 1.2rem; /* 폰트 크기 조절 */
            border-radius: 0.5rem;
            padding: 1rem;
            user-select: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-white m-0 p-0 overflow-hidden w-screen h-screen">

    <!-- 로비 화면 -->
    <div id="lobby-screen" class="w-full h-full flex flex-col items-center justify-center p-4">
        <h1 class="text-5xl font-bold text-yellow-300 mb-8">미니 게임 천국</h1>
        <div class="grid grid-cols-2 gap-4 w-full max-w-md">
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="brick-breaker"><div class="text-6xl mb-2">🧱</div><h2 class="text-xl font-semibold">벽돌깨기</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="snake"><div class="text-6xl mb-2">🐍</div><h2 class="text-xl font-semibold">지렁이 게임</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="runner"><div class="text-6xl mb-2">🏃</div><h2 class="text-xl font-semibold">러닝 게임</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="avoid"><div class="text-6xl mb-2">✈️</div><h2 class="text-xl font-semibold">별 피하기</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="stairs"><div class="text-6xl mb-2">🪜</div><h2 class="text-xl font-semibold">계단 오르기</h2></div>
        </div>
    </div>

    <!-- 게임 스크린 컨테이너 -->
    <div id="game-screens">
        <div id="brick-breaker-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">점수: <span id="bb-score">0</span></div><canvas id="brick-breaker-canvas"></canvas></div>
        <div id="snake-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">점수: <span id="snake-score">0</span></div><canvas id="snake-canvas"></canvas></div>
        <div id="runner-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">점수: <span id="runner-score">0</span></div><canvas id="runner-canvas"></canvas></div>
        <div id="avoid-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">점수: <span id="avoid-score">0</span></div><canvas id="avoid-canvas"></canvas></div>
        <div id="stairs-screen" class="game-screen hidden">
            <button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button>
            <div class="score-display">점수: <span id="stairs-score">0</span></div>
            <canvas id="stairs-canvas"></canvas>
            <div class="game-controls flex justify-between">
                <button id="stairs-change-go" class="control-btn w-1/2 mr-1">방향전환 & 전진</button>
                <button id="stairs-go-straight" class="control-btn w-1/2 ml-1">직진</button>
            </div>
        </div>
    </div>

<script>
// --- 메인 앱 로직 ---
const lobbyScreen = document.getElementById('lobby-screen');
const gameScreensContainer = document.getElementById('game-screens');
const gameCards = document.querySelectorAll('.game-card');
const backButtons = document.querySelectorAll('.back-button');

let activeGame = null;

// --- 유틸리티 함수 ---
function showAlertAndReturn(message) {
    setTimeout(() => {
        alert(message);
        showScreen('lobby-screen');
    }, 10);
}

function showScreen(screenId) {
    lobbyScreen.classList.add('hidden');
    Array.from(gameScreensContainer.children).forEach(screen => screen.classList.add('hidden'));

    if (screenId === 'lobby-screen') {
        lobbyScreen.classList.remove('hidden');
        if (activeGame && activeGame.stop) {
            activeGame.stop();
            activeGame = null;
        }
    } else {
        const screen = document.getElementById(screenId);
        if (screen) screen.classList.remove('hidden');
    }
}

// --- 벽돌깨기 게임 ---
const brickBreakerGame = (() => {
    const canvas = document.getElementById('brick-breaker-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('bb-score');
    let animationFrameId;

    let ball, paddle, bricks, score;
    const PADDLE_WIDTH = 100, PADDLE_HEIGHT = 15, BALL_RADIUS = 10;
    const BRICK_ROW_COUNT = 5, BRICK_COLUMN_COUNT = 7, BRICK_HEIGHT = 20, BRICK_PADDING = 10;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function init() {
        resizeCanvas();
        score = 0;
        scoreEl.textContent = 0;
        
        paddle = { x: (canvas.width - PADDLE_WIDTH) / 2, y: canvas.height - PADDLE_HEIGHT - 40, width: PADDLE_WIDTH, height: PADDLE_HEIGHT };
        ball = { x: canvas.width / 2, y: paddle.y - BALL_RADIUS, radius: BALL_RADIUS, dx: 4, dy: -4 };
        
        bricks = [];
        const BRICK_WIDTH = (canvas.width - BRICK_PADDING * (BRICK_COLUMN_COUNT + 1)) / BRICK_COLUMN_COUNT;
        for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
            bricks[c] = [];
            for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                bricks[c][r] = { 
                    x: c * (BRICK_WIDTH + BRICK_PADDING) + BRICK_PADDING, 
                    y: r * (BRICK_HEIGHT + BRICK_PADDING) + BRICK_PADDING + 50, 
                    status: 1 
                };
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0095DD';
        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        
        const BRICK_WIDTH = (canvas.width - BRICK_PADDING * (BRICK_COLUMN_COUNT + 1)) / BRICK_COLUMN_COUNT;
        bricks.forEach((column, c) => {
            column.forEach((brick, r) => {
                if (brick.status === 1) {
                    ctx.fillStyle = `hsl(${c * 30}, 70%, 50%)`;
                    ctx.fillRect(brick.x, brick.y, BRICK_WIDTH, BRICK_HEIGHT);
                }
            });
        });
    }

    function update() {
        ball.x += ball.dx;
        ball.y += ball.dy;

        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx *= -1;
        if (ball.y - ball.radius < 0) ball.dy *= -1;

        if (ball.y + ball.radius > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
            ball.dy = -ball.dy;
        }

        const BRICK_WIDTH = (canvas.width - BRICK_PADDING * (BRICK_COLUMN_COUNT + 1)) / BRICK_COLUMN_COUNT;
        let allBricksBroken = true;
        bricks.forEach(column => {
            column.forEach(brick => {
                if (brick.status === 1) {
                    allBricksBroken = false;
                    if (ball.x > brick.x && ball.x < brick.x + BRICK_WIDTH && ball.y > brick.y && ball.y < brick.y + BRICK_HEIGHT) {
                        ball.dy *= -1;
                        brick.status = 0;
                        score++;
                        scoreEl.textContent = score;
                    }
                }
            });
        });

        if (allBricksBroken) {
            stop();
            showAlertAndReturn("승리!");
        }

        if (ball.y + ball.radius > canvas.height) {
            stop();
            showAlertAndReturn("게임 오버!");
        }
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function movePaddle(e) {
        e.preventDefault();
        const touchX = e.touches ? e.touches[0].clientX : e.clientX;
        paddle.x = touchX - paddle.width / 2;
        if (paddle.x < 0) paddle.x = 0;
        if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
    }

    function start() {
        init();
        document.addEventListener('mousemove', movePaddle);
        canvas.addEventListener('touchmove', movePaddle, { passive: false });
        gameLoop();
    }

    function stop() {
        cancelAnimationFrame(animationFrameId);
        document.removeEventListener('mousemove', movePaddle);
        canvas.removeEventListener('touchmove', movePaddle);
    }

    return { start, stop };
})();

// --- 지렁이 게임 ---
const snakeGame = (() => {
    const canvas = document.getElementById('snake-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('snake-score');
    let gameInterval;

    const TILE_SIZE = 20;
    let snake, food, dx, dy, score, tileCountX, tileCountY;
    let touchStartX, touchStartY;
    
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        tileCountX = Math.floor(canvas.width / TILE_SIZE);
        tileCountY = Math.floor(canvas.height / TILE_SIZE);
    }

    function init() {
        resizeCanvas();
        score = 0;
        scoreEl.textContent = 0;
        snake = [{ x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) }];
        dx = 1; dy = 0;
        spawnFood();
    }

    function spawnFood() {
        food = {
            x: Math.floor(Math.random() * tileCountX),
            y: Math.floor(Math.random() * tileCountY)
        };
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        snake.forEach((segment, index) => {
            ctx.fillStyle = index === 0 ? 'lime' : 'green';
            ctx.fillRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
        });
        ctx.fillStyle = 'red';
        ctx.fillRect(food.x * TILE_SIZE, food.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
    }
    
    function update() {
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };
        
        if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY || checkCollision(head)) {
            stop();
            showAlertAndReturn("게임 오버!");
            return;
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
            score++;
            scoreEl.textContent = score;
            spawnFood();
        } else {
            snake.pop();
        }
    }
    
    function checkCollision(head) {
        return snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);
    }

    function gameLoop() {
        update();
        draw();
    }
    
    function handleKeyDown(e) {
        const key = e.key;
        if (key === 'ArrowUp' && dy === 0) { dx = 0; dy = -1; }
        else if (key === 'ArrowDown' && dy === 0) { dx = 0; dy = 1; }
        else if (key === 'ArrowLeft' && dx === 0) { dx = -1; dy = 0; }
        else if (key === 'ArrowRight' && dx === 0) { dx = 1; dy = 0; }
    }

    function handleTouchStart(e) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (!touchStartX || !touchStartY) return;
        const touchEndX = e.touches[0].clientX;
        const touchEndY = e.touches[0].clientY;

        const diffX = touchEndX - touchStartX;
        const diffY = touchEndY - touchStartY;

        if (Math.abs(diffX) > Math.abs(diffY)) { // Horizontal swipe
            if (diffX > 0 && dx === 0) { dx = 1; dy = 0; }
            else if (diffX < 0 && dx === 0) { dx = -1; dy = 0; }
        } else { // Vertical swipe
            if (diffY > 0 && dy === 0) { dx = 0; dy = 1; }
            else if (diffY < 0 && dy === 0) { dx = 0; dy = -1; }
        }
        touchStartX = null; touchStartY = null;
    }

    function start() {
        init();
        document.addEventListener('keydown', handleKeyDown);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        gameInterval = setInterval(gameLoop, 100);
    }

    function stop() {
        clearInterval(gameInterval);
        document.removeEventListener('keydown', handleKeyDown);
        canvas.removeEventListener('touchstart', handleTouchStart);
        canvas.removeEventListener('touchmove', handleTouchMove);
    }

    return { start, stop };
})();

// --- 러닝 게임 ---
const runnerGame = (() => {
    const canvas = document.getElementById('runner-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('runner-score');
    let animationFrameId;

    let player, obstacles, score, gameSpeed, groundY;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        groundY = canvas.height - 50;
    }

    function init() {
        resizeCanvas();
        score = 0;
        scoreEl.textContent = 0;
        gameSpeed = 5;
        player = { x: 50, y: groundY, width: 30, height: 50, dy: 0, gravity: 0.8, jumpStrength: -18, onGround: true };
        obstacles = [{ x: canvas.width, width: 20, height: 40 }];
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, groundY, canvas.width, 50);
        ctx.fillStyle = 'blue';
        ctx.fillRect(player.x, player.y - player.height, player.width, player.height);
        ctx.fillStyle = 'red';
        obstacles.forEach(obs => ctx.fillRect(obs.x, groundY - obs.height, obs.width, obs.height));
    }

    function update() {
        if (!player.onGround) {
            player.dy += player.gravity;
            player.y += player.dy;
        }
        if (player.y >= groundY) {
            player.y = groundY;
            player.onGround = true;
        }

        obstacles.forEach(obs => {
            obs.x -= gameSpeed;
            if (player.x < obs.x + obs.width && player.x + player.width > obs.x && player.y > groundY - obs.height) {
                stop();
                showAlertAndReturn("게임 오버!");
            }
        });
        
        if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 200 - Math.random() * 150) {
            obstacles.push({ x: canvas.width, width: 20 + Math.random() * 20, height: 30 + Math.random() * 30 });
        }
        if (obstacles.length > 0 && obstacles[0].x < -obstacles[0].width) {
            obstacles.shift();
            score++;
            scoreEl.textContent = score;
            gameSpeed += 0.1;
        }
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function handleJump() {
        if (player.onGround) {
            player.dy = player.jumpStrength;
            player.onGround = false;
        }
    }

    function handleKeyDown(e) {
        if (e.code === 'Space') handleJump();
    }

    function start() {
        init();
        document.addEventListener('keydown', handleKeyDown);
        canvas.addEventListener('touchstart', handleJump);
        gameLoop();
    }

    function stop() {
        cancelAnimationFrame(animationFrameId);
        document.removeEventListener('keydown', handleKeyDown);
        canvas.removeEventListener('touchstart', handleJump);
    }

    return { start, stop };
})();

// --- 별 피하기 게임 (수정됨) ---
const avoidGame = (() => {
    const canvas = document.getElementById('avoid-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('avoid-score');
    let animationFrameId;

    let player, stars, score, gameSpeed;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function init() {
        resizeCanvas();
        player = { x: canvas.width / 2, y: canvas.height / 2, size: 30 };
        stars = [];
        score = 0;
        scoreEl.textContent = 0;
        gameSpeed = 2;
    }
    
    function drawPlayer() {
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(player.x, player.y - 15);
        ctx.lineTo(player.x - 15, player.y + 15);
        ctx.lineTo(player.x + 15, player.y + 15);
        ctx.closePath();
        ctx.fill();
    }

    function drawStars() {
        ctx.fillStyle = 'yellow';
        stars.forEach(star => {
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(star.x + star.size * Math.cos(i * 2 * Math.PI / 5 * 2), star.y + star.size * Math.sin(i * 2 * Math.PI / 5 * 2));
                ctx.lineTo(star.x + star.size/2 * Math.cos((i * 2 + 1) * Math.PI / 5 * 2), star.y + star.size/2 * Math.sin((i * 2 + 1) * Math.PI / 5 * 2));
            }
            ctx.closePath();
            ctx.fill();
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawPlayer();
        drawStars();
    }

    function update() {
        score++;
        scoreEl.textContent = Math.floor(score / 10);
        gameSpeed += 0.002;

        // 별 생성
        if (Math.random() < 0.1) {
            let x, y;
            const edge = Math.floor(Math.random() * 4);
            if (edge === 0) { x = Math.random() * canvas.width; y = 0; } // Top
            else if (edge === 1) { x = canvas.width; y = Math.random() * canvas.height; } // Right
            else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height; } // Bottom
            else { x = 0; y = Math.random() * canvas.height; } // Left

            const angle = Math.atan2(player.y - y, player.x - x);
            stars.push({
                x, y,
                size: 5 + Math.random() * 10,
                dx: Math.cos(angle) * gameSpeed,
                dy: Math.sin(angle) * gameSpeed
            });
        }

        // 별 이동 및 충돌 감지
        stars.forEach((star, index) => {
            star.x += star.dx;
            star.y += star.dy;

            if (star.x < -20 || star.x > canvas.width + 20 || star.y < -20 || star.y > canvas.height + 20) {
                stars.splice(index, 1);
            }

            const dist = Math.hypot(player.x - star.x, player.y - star.y);
            if (dist < player.size / 2 + star.size / 2) {
                stop();
                showAlertAndReturn("게임 오버!");
            }
        });
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function movePlayer(e) {
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        player.x = touch.clientX;
        player.y = touch.clientY;
    }

    function start() {
        init();
        document.addEventListener('mousemove', movePlayer);
        canvas.addEventListener('touchmove', movePlayer, { passive: false });
        gameLoop();
    }

    function stop() {
        cancelAnimationFrame(animationFrameId);
        document.removeEventListener('mousemove', movePlayer);
        canvas.removeEventListener('touchmove', movePlayer);
    }

    return { start, stop };
})();

// --- 계단 오르기 ---
const stairsGame = (() => {
    const canvas = document.getElementById('stairs-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('stairs-score');
    let animationFrameId;

    let player, stairs, score, cameraY;
    const STAIR_HEIGHT = 20, STAIR_WIDTH = 100, STAIR_STEP_Y = 80, STAIR_STEP_X = 60;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function init() {
        resizeCanvas();
        score = 0;
        scoreEl.textContent = 0;
        cameraY = 0;
        stairs = [{ x: canvas.width / 2 - STAIR_WIDTH / 2, y: canvas.height - 120, direction: 'right' }];
        player = { 
            x: stairs[0].x + STAIR_WIDTH / 2, 
            y: stairs[0].y, 
            currentStairIndex: 0,
            facingDirection: 'right'
        };
        for (let i = 0; i < 20; i++) generateNewStair();
    }
    
    function generateNewStair() {
        const lastStair = stairs[stairs.length - 1];
        let newDirection = Math.random() < 0.5 ? 'left' : 'right';
        let newX = newDirection === 'left' ? lastStair.x - STAIR_STEP_X : lastStair.x + STAIR_STEP_X;
        if (newX + STAIR_WIDTH > canvas.width - 20) newDirection = 'left';
        else if (newX < 20) newDirection = 'right';
        newX = newDirection === 'left' ? lastStair.x - STAIR_STEP_X : lastStair.x + STAIR_STEP_X;
        stairs.push({ x: newX, y: lastStair.y - STAIR_STEP_Y, direction: newDirection });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(0, cameraY);
        stairs.forEach((stair, index) => {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(stair.x, stair.y, STAIR_WIDTH, STAIR_HEIGHT);
            if(index === player.currentStairIndex + 1) {
                ctx.fillStyle = 'white';
                ctx.font = '24px Jua';
                ctx.textAlign = 'center';
                ctx.fillText(stair.direction === 'left' ? '◀' : '▶', stair.x + STAIR_WIDTH / 2, stair.y - 10);
            }
        });
        ctx.fillStyle = 'purple';
        ctx.fillRect(player.x - 15, player.y - 40, 30, 40);
        
        ctx.fillStyle = 'yellow';
        ctx.font = '20px Jua';
        ctx.textAlign = 'center';
        const indicatorText = player.facingDirection === 'left' ? '◀' : '▶';
        ctx.fillText(indicatorText, player.x, player.y - 50);

        ctx.restore();
    }

    function update() {
        cameraY += (-(player.y - canvas.height * 0.7) - cameraY) * 0.1;
    }
    
    function performMove(intendedDirection) {
        const nextStair = stairs[player.currentStairIndex + 1];
        if (intendedDirection === nextStair.direction) {
            score++;
            scoreEl.textContent = score;
            player.currentStairIndex++;
            player.x = nextStair.x + STAIR_WIDTH / 2;
            player.y = nextStair.y;
            generateNewStair();
        } else {
            stop();
            showAlertAndReturn("게임 오버!");
        }
    }

    function handleChangeAndGo() {
        player.facingDirection = player.facingDirection === 'left' ? 'right' : 'left';
        performMove(player.facingDirection);
    }

    function handleGoStraight() {
        performMove(player.facingDirection);
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function handleKeyDown(e) {
        if (e.key === 'ArrowLeft') handleChangeAndGo();
        if (e.key === 'ArrowRight') handleGoStraight();
    }

    function start() {
        init();
        document.getElementById('stairs-change-go').onclick = handleChangeAndGo;
        document.getElementById('stairs-go-straight').onclick = handleGoStraight;
        document.addEventListener('keydown', handleKeyDown);
        gameLoop();
    }

    function stop() {
        cancelAnimationFrame(animationFrameId);
        document.removeEventListener('keydown', handleKeyDown);
        document.getElementById('stairs-change-go').onclick = null;
        document.getElementById('stairs-go-straight').onclick = null;
    }
    
    return { start, stop };
})();

// --- 게임 카드 클릭 이벤트 핸들러 ---
gameCards.forEach(card => {
    card.addEventListener('click', () => {
        const gameId = card.dataset.game;
        if (!gameId) return;
        
        const gameMap = {
            'brick-breaker': brickBreakerGame,
            'snake': snakeGame,
            'runner': runnerGame,
            'avoid': avoidGame,
            'stairs': stairsGame,
        };
        activeGame = gameMap[gameId];
        if (activeGame) {
            showScreen(`${gameId}-screen`);
            activeGame.start();
        }
    });
});

</script>
</body>
</html>
