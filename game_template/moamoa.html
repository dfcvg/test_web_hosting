<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>웹게임 포털</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Jua&display=swap" rel="stylesheet">
    <style>
        body, button, h1, p, span, div {
            font-family: 'Jua', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        .hidden { display: none; }
        .game-screen {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            background-color: #1a202c;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        canvas {
            background-color: #000;
            display: block;
        }
        .back-button { position: absolute; top: 1rem; left: 1rem; z-index: 50; }
        .score-display { position: absolute; top: 1rem; right: 1rem; z-index: 50; font-size: 1.5rem; color: white; }
        .game-controls { position: absolute; bottom: 0; left: 0; width: 100%; padding: 1rem; box-sizing: border-box; z-index: 50; }
        .control-btn { background-color: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.5); color: white; font-size: 1.2rem; border-radius: 0.5rem; padding: 1rem; user-select: none; }
        
        /* 카드 뒤집기 스타일 */
        #memory-board { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
        .memory-card { width: 100%; aspect-ratio: 1 / 1; background-color: #4a5568; border-radius: 5px; display: flex; align-items: center; justify-content: center; font-size: 2.5rem; cursor: pointer; transform-style: preserve-3d; transition: transform 0.5s; }
        .memory-card .card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; display: flex; align-items: center; justify-content: center; }
        .memory-card .card-back { transform: rotateY(180deg); }
        .memory-card.is-flipped { transform: rotateY(180deg); }
        .memory-card.is-matched { background-color: #2d3748; opacity: 0.5; }

        /* 2048 스타일 */
        #game-2048-board { display: grid; grid-template-columns: repeat(4, 1fr); grid-gap: 10px; padding: 10px; background-color: #bbada0; border-radius: 6px; }
        .tile-2048 { display: flex; align-items: center; justify-content: center; font-size: 2rem; font-weight: bold; border-radius: 3px; transition: all 0.1s ease-in-out; }
        .tile-2048[data-value="2"] { background-color: #eee4da; color: #776e65; } .tile-2048[data-value="4"] { background-color: #ede0c8; color: #776e65; } .tile-2048[data-value="8"] { background-color: #f2b179; color: #f9f6f2; } .tile-2048[data-value="16"] { background-color: #f59563; color: #f9f6f2; } .tile-2048[data-value="32"] { background-color: #f67c5f; color: #f9f6f2; } .tile-2048[data-value="64"] { background-color: #f65e3b; color: #f9f6f2; } .tile-2048[data-value="128"] { background-color: #edcf72; color: #f9f6f2; } .tile-2048[data-value="256"] { background-color: #edcc61; color: #f9f6f2; } .tile-2048[data-value="512"] { background-color: #edc850; color: #f9f6f2; } .tile-2048[data-value="1024"] { background-color: #edc53f; color: #f9f6f2; } .tile-2048[data-value="2048"] { background-color: #edc22e; color: #f9f6f2; }
    </style>
</head>
<body class="bg-gray-900 text-white m-0 p-0 overflow-hidden w-screen h-screen">

    <!-- 로비 화면 -->
    <div id="lobby-screen" class="w-full h-full flex flex-col items-center p-4 overflow-y-auto">
        <h1 class="text-5xl font-bold text-yellow-300 my-8">미니 게임 천국</h1>
        <div class="grid grid-cols-2 sm:grid-cols-3 gap-4 w-full max-w-lg">
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="brick-breaker"><div class="text-6xl mb-2">🧱</div><h2 class="text-xl font-semibold">벽돌깨기</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="snake"><div class="text-6xl mb-2">🐍</div><h2 class="text-xl font-semibold">지렁이 게임</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="runner"><div class="text-6xl mb-2">🏃</div><h2 class="text-xl font-semibold">러닝 게임</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="avoid"><div class="text-6xl mb-2">✈️</div><h2 class="text-xl font-semibold">별 피하기</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="stairs"><div class="text-6xl mb-2">🪜</div><h2 class="text-xl font-semibold">계단 오르기</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="2048"><div class="text-6xl mb-2">🔢</div><h2 class="text-xl font-semibold">2048</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="flappy-bird"><div class="text-6xl mb-2">🐦</div><h2 class="text-xl font-semibold">플래피 버드</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="whack-a-mole"><div class="text-6xl mb-2">🔨</div><h2 class="text-xl font-semibold">두더지 잡기</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="memory"><div class="text-6xl mb-2">🃏</div><h2 class="text-xl font-semibold">카드 뒤집기</h2></div>
            <div class="game-card bg-gray-800 p-4 rounded-lg text-center transform hover:scale-105 transition-transform cursor-pointer" data-game="jump"><div class="text-6xl mb-2">⬆️</div><h2 class="text-xl font-semibold">점프 게임</h2></div>
        </div>
    </div>

    <!-- 게임 스크린 컨테이너 -->
    <div id="game-screens">
        <div id="brick-breaker-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">점수: <span id="bb-score">0</span></div><canvas id="brick-breaker-canvas"></canvas></div>
        <div id="snake-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">점수: <span id="snake-score">0</span></div><canvas id="snake-canvas"></canvas></div>
        <div id="runner-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">점수: <span id="runner-score">0</span></div><canvas id="runner-canvas"></canvas></div>
        <div id="avoid-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">점수: <span id="avoid-score">0</span></div><canvas id="avoid-canvas"></canvas></div>
        <div id="stairs-screen" class="game-screen hidden">
            <button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button>
            <div class="score-display">점수: <span id="stairs-score">0</span></div>
            <canvas id="stairs-canvas"></canvas>
            <div class="game-controls flex justify-between">
                <button id="stairs-change-go" class="control-btn w-1/2 mr-1">방향전환 & 전진</button>
                <button id="stairs-go-straight" class="control-btn w-1/2 ml-1">직진</button>
            </div>
        </div>
        <div id="2048-screen" class="game-screen justify-center items-center p-4">
            <button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button>
            <div class="score-display">점수: <span id="2048-score">0</span></div>
            <div id="game-2048-board" class="w-full max-w-md aspect-square"></div>
        </div>
        <div id="flappy-bird-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">점수: <span id="flappy-score">0</span></div><canvas id="flappy-bird-canvas"></canvas></div>
        <div id="whack-a-mole-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">점수: <span id="whack-score">0</span> | 시간: <span id="whack-time">30</span></div><canvas id="whack-a-mole-canvas"></canvas></div>
        <div id="memory-screen" class="game-screen justify-center items-center p-4">
            <button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button>
            <div class="score-display">시도: <span id="memory-tries">0</span></div>
            <div id="memory-board" class="w-full max-w-md aspect-square"></div>
        </div>
        <div id="jump-screen" class="game-screen hidden"><button class="back-button bg-red-500 px-4 py-2 rounded">← 로비로</button><div class="score-display">높이: <span id="jump-score">0</span></div><canvas id="jump-canvas"></canvas></div>
    </div>

<script>
// --- 메인 앱 로직 ---
const lobbyScreen = document.getElementById('lobby-screen');
const gameScreensContainer = document.getElementById('game-screens');
const gameCards = document.querySelectorAll('.game-card');
const backButtons = document.querySelectorAll('.back-button');

let activeGame = null;

// --- 유틸리티 함수 ---
function showAlertAndReturn(message) {
    setTimeout(() => {
        alert(message);
        showScreen('lobby-screen');
    }, 10);
}

function showScreen(screenId) {
    lobbyScreen.classList.add('hidden');
    Array.from(gameScreensContainer.children).forEach(screen => screen.classList.add('hidden'));

    if (screenId === 'lobby-screen') {
        lobbyScreen.classList.remove('hidden');
        if (activeGame && activeGame.stop) {
            activeGame.stop();
            activeGame = null;
        }
    } else {
        const screen = document.getElementById(screenId);
        if (screen) screen.classList.remove('hidden');
    }
}

// --- 게임 객체들 ---
const brickBreakerGame = {}; const snakeGame = {}; const runnerGame = {}; const avoidGame = {}; const stairsGame = {}; const game2048 = {}; const flappyBirdGame = {}; const whackAMoleGame = {}; const memoryGame = {}; const jumpGame = {};

// --- 게임 카드 클릭 이벤트 핸들러 ---
gameCards.forEach(card => {
    card.addEventListener('click', () => {
        const gameId = card.dataset.game;
        if (!gameId) return;
        
        const gameMap = {
            'brick-breaker': brickBreakerGame, 'snake': snakeGame, 'runner': runnerGame,
            'avoid': avoidGame, 'stairs': stairsGame, '2048': game2048,
            'flappy-bird': flappyBirdGame, 'whack-a-mole': whackAMoleGame,
            'memory': memoryGame, 'jump': jumpGame
        };
        activeGame = gameMap[gameId];
        if (activeGame && activeGame.start) {
            showScreen(`${gameId}-screen`);
            activeGame.start();
        }
    });
});

backButtons.forEach(button => button.addEventListener('click', () => showScreen('lobby-screen')));

// --- 각 게임 로직 구현 ---

// Brick Breaker
Object.assign(brickBreakerGame, (() => {
    const canvas = document.getElementById('brick-breaker-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('bb-score');
    let animationFrameId;

    let ball, paddle, bricks, score;
    const PADDLE_WIDTH = 100, PADDLE_HEIGHT = 15, BALL_RADIUS = 10;
    const BRICK_ROW_COUNT = 5, BRICK_COLUMN_COUNT = 7, BRICK_HEIGHT = 20, BRICK_PADDING = 10;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function init() {
        resizeCanvas();
        score = 0;
        scoreEl.textContent = 0;
        
        paddle = { x: (canvas.width - PADDLE_WIDTH) / 2, y: canvas.height - PADDLE_HEIGHT - 40, width: PADDLE_WIDTH, height: PADDLE_HEIGHT };
        ball = { x: canvas.width / 2, y: paddle.y - BALL_RADIUS, radius: BALL_RADIUS, dx: 4, dy: -4 };
        
        bricks = [];
        const BRICK_WIDTH = (canvas.width - BRICK_PADDING * (BRICK_COLUMN_COUNT + 1)) / BRICK_COLUMN_COUNT;
        for (let c = 0; c < BRICK_COLUMN_COUNT; c++) {
            bricks[c] = [];
            for (let r = 0; r < BRICK_ROW_COUNT; r++) {
                bricks[c][r] = { 
                    x: c * (BRICK_WIDTH + BRICK_PADDING) + BRICK_PADDING, 
                    y: r * (BRICK_HEIGHT + BRICK_PADDING) + BRICK_PADDING + 50, 
                    status: 1 
                };
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0095DD';
        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        
        const BRICK_WIDTH = (canvas.width - BRICK_PADDING * (BRICK_COLUMN_COUNT + 1)) / BRICK_COLUMN_COUNT;
        bricks.forEach((column, c) => {
            column.forEach((brick, r) => {
                if (brick.status === 1) {
                    ctx.fillStyle = `hsl(${c * 30}, 70%, 50%)`;
                    ctx.fillRect(brick.x, brick.y, BRICK_WIDTH, BRICK_HEIGHT);
                }
            });
        });
    }

    function update() {
        ball.x += ball.dx;
        ball.y += ball.dy;

        if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx *= -1;
        if (ball.y - ball.radius < 0) ball.dy *= -1;

        if (ball.y + ball.radius > paddle.y && ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
            ball.dy = -ball.dy;
        }

        const BRICK_WIDTH = (canvas.width - BRICK_PADDING * (BRICK_COLUMN_COUNT + 1)) / BRICK_COLUMN_COUNT;
        let allBricksBroken = true;
        bricks.forEach(column => {
            column.forEach(brick => {
                if (brick.status === 1) {
                    allBricksBroken = false;
                    if (ball.x > brick.x && ball.x < brick.x + BRICK_WIDTH && ball.y > brick.y && ball.y < brick.y + BRICK_HEIGHT) {
                        ball.dy *= -1;
                        brick.status = 0;
                        score++;
                        scoreEl.textContent = score;
                    }
                }
            });
        });

        if (allBricksBroken) {
            stop();
            showAlertAndReturn("승리!");
        }

        if (ball.y + ball.radius > canvas.height) {
            stop();
            showAlertAndReturn("게임 오버!");
        }
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function movePaddle(e) {
        e.preventDefault();
        const touchX = e.touches ? e.touches[0].clientX : e.clientX;
        paddle.x = touchX - paddle.width / 2;
        if (paddle.x < 0) paddle.x = 0;
        if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
    }

    function start() {
        init();
        document.addEventListener('mousemove', movePaddle);
        canvas.addEventListener('touchmove', movePaddle, { passive: false });
        gameLoop();
    }

    function stop() {
        cancelAnimationFrame(animationFrameId);
        document.removeEventListener('mousemove', movePaddle);
        canvas.removeEventListener('touchmove', movePaddle);
    }

    return { start, stop };
})());

// Snake
Object.assign(snakeGame, (() => {
    const canvas = document.getElementById('snake-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('snake-score');
    let gameInterval;

    const TILE_SIZE = 20;
    let snake, food, dx, dy, score, tileCountX, tileCountY;
    let touchStartX, touchStartY;
    
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        tileCountX = Math.floor(canvas.width / TILE_SIZE);
        tileCountY = Math.floor(canvas.height / TILE_SIZE);
    }

    function init() {
        resizeCanvas();
        score = 0;
        scoreEl.textContent = 0;
        snake = [{ x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) }];
        dx = 1; dy = 0;
        spawnFood();
    }

    function spawnFood() {
        food = {
            x: Math.floor(Math.random() * tileCountX),
            y: Math.floor(Math.random() * tileCountY)
        };
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        snake.forEach((segment, index) => {
            ctx.fillStyle = index === 0 ? 'lime' : 'green';
            ctx.fillRect(segment.x * TILE_SIZE, segment.y * TILE_SIZE, TILE_SIZE - 1, TILE_SIZE - 1);
        });
        ctx.fillStyle = 'red';
        ctx.fillRect(food.x * TILE_SIZE, food.y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
    }
    
    function update() {
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };
        
        if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY || checkCollision(head)) {
            stop();
            showAlertAndReturn("게임 오버!");
            return;
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
            score++;
            scoreEl.textContent = score;
            spawnFood();
        } else {
            snake.pop();
        }
    }
    
    function checkCollision(head) {
        return snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);
    }

    function gameLoop() {
        update();
        draw();
    }
    
    function handleKeyDown(e) {
        const key = e.key;
        if (key === 'ArrowUp' && dy === 0) { dx = 0; dy = -1; }
        else if (key === 'ArrowDown' && dy === 0) { dx = 0; dy = 1; }
        else if (key === 'ArrowLeft' && dx === 0) { dx = -1; dy = 0; }
        else if (key === 'ArrowRight' && dx === 0) { dx = 1; dy = 0; }
    }

    function handleTouchStart(e) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }

    function handleTouchMove(e) {
        e.preventDefault();
        if (!touchStartX || !touchStartY) return;
        const touchEndX = e.touches[0].clientX;
        const touchEndY = e.touches[0].clientY;

        const diffX = touchEndX - touchStartX;
        const diffY = touchEndY - touchStartY;

        if (Math.abs(diffX) > Math.abs(diffY)) { // Horizontal swipe
            if (diffX > 0 && dx === 0) { dx = 1; dy = 0; }
            else if (diffX < 0 && dx === 0) { dx = -1; dy = 0; }
        } else { // Vertical swipe
            if (diffY > 0 && dy === 0) { dx = 0; dy = 1; }
            else if (diffY < 0 && dy === 0) { dx = 0; dy = -1; }
        }
        touchStartX = null; touchStartY = null;
    }

    function start() {
        init();
        document.addEventListener('keydown', handleKeyDown);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        gameInterval = setInterval(gameLoop, 100);
    }

    function stop() {
        clearInterval(gameInterval);
        document.removeEventListener('keydown', handleKeyDown);
        canvas.removeEventListener('touchstart', handleTouchStart);
        canvas.removeEventListener('touchmove', handleTouchMove);
    }

    return { start, stop };
})());

// Runner
Object.assign(runnerGame, (() => {
    const canvas = document.getElementById('runner-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('runner-score');
    let animationFrameId;

    let player, obstacles, score, gameSpeed, groundY;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        groundY = canvas.height - 50;
    }

    function init() {
        resizeCanvas();
        score = 0;
        scoreEl.textContent = 0;
        gameSpeed = 5;
        player = { x: 50, y: groundY, width: 30, height: 50, dy: 0, gravity: 0.8, jumpStrength: -18, onGround: true };
        obstacles = [{ x: canvas.width, width: 20, height: 40 }];
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(0, groundY, canvas.width, 50);
        ctx.fillStyle = 'blue';
        ctx.fillRect(player.x, player.y - player.height, player.width, player.height);
        ctx.fillStyle = 'red';
        obstacles.forEach(obs => ctx.fillRect(obs.x, groundY - obs.height, obs.width, obs.height));
    }

    function update() {
        if (!player.onGround) {
            player.dy += player.gravity;
            player.y += player.dy;
        }
        if (player.y >= groundY) {
            player.y = groundY;
            player.onGround = true;
        }

        obstacles.forEach(obs => {
            obs.x -= gameSpeed;
            if (player.x < obs.x + obs.width && player.x + player.width > obs.x && player.y > groundY - obs.height) {
                stop();
                showAlertAndReturn("게임 오버!");
            }
        });
        
        if (obstacles.length === 0 || obstacles[obstacles.length - 1].x < canvas.width - 200 - Math.random() * 150) {
            obstacles.push({ x: canvas.width, width: 20 + Math.random() * 20, height: 30 + Math.random() * 30 });
        }
        if (obstacles.length > 0 && obstacles[0].x < -obstacles[0].width) {
            obstacles.shift();
            score++;
            scoreEl.textContent = score;
            gameSpeed += 0.1;
        }
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function handleJump() {
        if (player.onGround) {
            player.dy = player.jumpStrength;
            player.onGround = false;
        }
    }

    function handleKeyDown(e) {
        if (e.code === 'Space') handleJump();
    }

    function start() {
        init();
        document.addEventListener('keydown', handleKeyDown);
        canvas.addEventListener('touchstart', handleJump);
        gameLoop();
    }

    function stop() {
        cancelAnimationFrame(animationFrameId);
        document.removeEventListener('keydown', handleKeyDown);
        canvas.removeEventListener('touchstart', handleJump);
    }

    return { start, stop };
})());

// Avoid
Object.assign(avoidGame, (() => {
    const canvas = document.getElementById('avoid-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('avoid-score');
    let animationFrameId;

    let player, stars, score, gameSpeed;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function init() {
        resizeCanvas();
        player = { x: canvas.width / 2, y: canvas.height / 2, size: 30 };
        stars = [];
        score = 0;
        scoreEl.textContent = 0;
        gameSpeed = 2;
    }
    
    function drawPlayer() {
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.moveTo(player.x, player.y - 15);
        ctx.lineTo(player.x - 15, player.y + 15);
        ctx.lineTo(player.x + 15, player.y + 15);
        ctx.closePath();
        ctx.fill();
    }

    function drawStars() {
        ctx.fillStyle = 'yellow';
        stars.forEach(star => {
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(star.x + star.size * Math.cos(i * 2 * Math.PI / 5 * 2), star.y + star.size * Math.sin(i * 2 * Math.PI / 5 * 2));
                ctx.lineTo(star.x + star.size/2 * Math.cos((i * 2 + 1) * Math.PI / 5 * 2), star.y + star.size/2 * Math.sin((i * 2 + 1) * Math.PI / 5 * 2));
            }
            ctx.closePath();
            ctx.fill();
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawPlayer();
        drawStars();
    }

    function update() {
        score++;
        scoreEl.textContent = Math.floor(score / 10);
        gameSpeed += 0.002;

        if (Math.random() < 0.1) {
            let x, y;
            const edge = Math.floor(Math.random() * 4);
            if (edge === 0) { x = Math.random() * canvas.width; y = 0; }
            else if (edge === 1) { x = canvas.width; y = Math.random() * canvas.height; }
            else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height; }
            else { x = 0; y = Math.random() * canvas.height; }

            const angle = Math.atan2(player.y - y, player.x - x);
            stars.push({
                x, y,
                size: 5 + Math.random() * 10,
                dx: Math.cos(angle) * gameSpeed,
                dy: Math.sin(angle) * gameSpeed
            });
        }

        stars.forEach((star, index) => {
            star.x += star.dx;
            star.y += star.dy;

            if (star.x < -20 || star.x > canvas.width + 20 || star.y < -20 || star.y > canvas.height + 20) {
                stars.splice(index, 1);
            }

            const dist = Math.hypot(player.x - star.x, player.y - star.y);
            if (dist < player.size / 2 + star.size / 2) {
                stop();
                showAlertAndReturn("게임 오버!");
            }
        });
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function movePlayer(e) {
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        player.x = touch.clientX;
        player.y = touch.clientY;
    }

    function start() {
        init();
        document.addEventListener('mousemove', movePlayer);
        canvas.addEventListener('touchmove', movePlayer, { passive: false });
        gameLoop();
    }

    function stop() {
        cancelAnimationFrame(animationFrameId);
        document.removeEventListener('mousemove', movePlayer);
        canvas.removeEventListener('touchmove', movePlayer);
    }

    return { start, stop };
})());

// Stairs
Object.assign(stairsGame, (() => {
    const canvas = document.getElementById('stairs-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('stairs-score');
    let animationFrameId;

    let player, stairs, score, cameraY;
    const STAIR_HEIGHT = 20, STAIR_WIDTH = 100, STAIR_STEP_Y = 80, STAIR_STEP_X = 60;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function init() {
        resizeCanvas();
        score = 0;
        scoreEl.textContent = 0;
        cameraY = 0;
        stairs = [{ x: canvas.width / 2 - STAIR_WIDTH / 2, y: canvas.height - 120, direction: 'right' }];
        player = { 
            x: stairs[0].x + STAIR_WIDTH / 2, 
            y: stairs[0].y, 
            currentStairIndex: 0,
            facingDirection: 'right'
        };
        for (let i = 0; i < 20; i++) generateNewStair();
    }
    
    function generateNewStair() {
        const lastStair = stairs[stairs.length - 1];
        let newDirection = Math.random() < 0.5 ? 'left' : 'right';
        let newX = newDirection === 'left' ? lastStair.x - STAIR_STEP_X : lastStair.x + STAIR_STEP_X;
        if (newX + STAIR_WIDTH > canvas.width - 20) newDirection = 'left';
        else if (newX < 20) newDirection = 'right';
        newX = newDirection === 'left' ? lastStair.x - STAIR_STEP_X : lastStair.x + STAIR_STEP_X;
        stairs.push({ x: newX, y: lastStair.y - STAIR_STEP_Y, direction: newDirection });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(0, cameraY);
        stairs.forEach((stair, index) => {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(stair.x, stair.y, STAIR_WIDTH, STAIR_HEIGHT);
            if(index === player.currentStairIndex + 1) {
                ctx.fillStyle = 'white';
                ctx.font = '24px Jua';
                ctx.textAlign = 'center';
                ctx.fillText(stair.direction === 'left' ? '◀' : '▶', stair.x + STAIR_WIDTH / 2, stair.y - 10);
            }
        });
        ctx.fillStyle = 'purple';
        ctx.fillRect(player.x - 15, player.y - 40, 30, 40);
        
        ctx.fillStyle = 'yellow';
        ctx.font = '20px Jua';
        ctx.textAlign = 'center';
        const indicatorText = player.facingDirection === 'left' ? '◀' : '▶';
        ctx.fillText(indicatorText, player.x, player.y - 50);

        ctx.restore();
    }

    function update() {
        cameraY += (-(player.y - canvas.height * 0.7) - cameraY) * 0.1;
    }
    
    function performMove(intendedDirection) {
        const nextStair = stairs[player.currentStairIndex + 1];
        if (intendedDirection === nextStair.direction) {
            score++;
            scoreEl.textContent = score;
            player.currentStairIndex++;
            player.x = nextStair.x + STAIR_WIDTH / 2;
            player.y = nextStair.y;
            generateNewStair();
        } else {
            stop();
            showAlertAndReturn("게임 오버!");
        }
    }

    function handleChangeAndGo() {
        player.facingDirection = player.facingDirection === 'left' ? 'right' : 'left';
        performMove(player.facingDirection);
    }

    function handleGoStraight() {
        performMove(player.facingDirection);
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function handleKeyDown(e) {
        if (e.key === 'ArrowLeft') handleChangeAndGo();
        if (e.key === 'ArrowRight') handleGoStraight();
    }

    function start() {
        init();
        document.getElementById('stairs-change-go').onclick = handleChangeAndGo;
        document.getElementById('stairs-go-straight').onclick = handleGoStraight;
        document.addEventListener('keydown', handleKeyDown);
        gameLoop();
    }

    function stop() {
        cancelAnimationFrame(animationFrameId);
        document.removeEventListener('keydown', handleKeyDown);
        document.getElementById('stairs-change-go').onclick = null;
        document.getElementById('stairs-go-straight').onclick = null;
    }
    
    return { start, stop };
})());

// 2048
Object.assign(game2048, (() => {
    const boardEl = document.getElementById('game-2048-board');
    const scoreEl = document.getElementById('2048-score');
    let board = [];
    let score = 0;
    let touchStartX, touchStartY;

    function init() {
        board = Array.from({ length: 4 }, () => Array(4).fill(0));
        score = 0;
        addRandomTile();
        addRandomTile();
        drawBoard();
    }

    function drawBoard() {
        boardEl.innerHTML = '';
        scoreEl.textContent = score;
        for (let y = 0; y < 4; y++) {
            for (let x = 0; x < 4; x++) {
                const tile = document.createElement('div');
                tile.className = 'tile-2048';
                const value = board[y][x];
                if (value > 0) {
                    tile.textContent = value;
                    tile.dataset.value = value;
                }
                boardEl.appendChild(tile);
            }
        }
    }

    function addRandomTile() {
        let emptyTiles = [];
        for (let y = 0; y < 4; y++) {
            for (let x = 0; x < 4; x++) {
                if (board[y][x] === 0) emptyTiles.push({ x, y });
            }
        }
        if (emptyTiles.length > 0) {
            const { x, y } = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
            board[y][x] = Math.random() < 0.9 ? 2 : 4;
        }
    }
    
    function slide(row) {
        let arr = row.filter(val => val);
        let missing = 4 - arr.length;
        let zeros = Array(missing).fill(0);
        arr = zeros.concat(arr);
        return arr;
    }

    function combine(row) {
        for (let i = 3; i >= 1; i--) {
            if (row[i] === row[i - 1]) {
                row[i] *= 2;
                score += row[i];
                row[i - 1] = 0;
            }
        }
        return row;
    }

    function operate(row) {
        row = slide(row);
        row = combine(row);
        row = slide(row);
        return row;
    }

    function rotateBoard(board) {
        let newBoard = [];
        for (let i = 0; i < 4; i++) {
            newBoard.push([]);
            for (let j = 0; j < 4; j++) {
                newBoard[i].push(board[j][i]);
            }
        }
        return newBoard;
    }

    function move(dir) {
        let moved = false;
        let originalBoard = JSON.stringify(board);

        if (dir === 'left' || dir === 'right') {
            for (let i = 0; i < 4; i++) {
                let row = board[i];
                if (dir === 'right') row.reverse();
                row = operate(row);
                if (dir === 'right') row.reverse();
                board[i] = row;
            }
        } else if (dir === 'up' || dir === 'down') {
            board = rotateBoard(board);
            for (let i = 0; i < 4; i++) {
                let row = board[i];
                if (dir === 'down') row.reverse();
                row = operate(row);
                if (dir === 'down') row.reverse();
                board[i] = row;
            }
            board = rotateBoard(board);
        }

        if (JSON.stringify(board) !== originalBoard) {
            addRandomTile();
        }
        drawBoard();
    }
    
    function handleKeyDown(e) {
        if (e.key === 'ArrowUp') move('up');
        else if (e.key === 'ArrowDown') move('down');
        else if (e.key === 'ArrowLeft') move('left');
        else if (e.key === 'ArrowRight') move('right');
    }
    function handleTouchStart(e) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }
    function handleTouchEnd(e) {
        if (!touchStartX || !touchStartY) return;
        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const dx = touchEndX - touchStartX;
        const dy = touchEndY - touchStartY;
        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0) move('right'); else move('left');
        } else {
            if (dy > 0) move('down'); else move('up');
        }
        touchStartX = null; touchStartY = null;
    }

    function start() {
        init();
        document.addEventListener('keydown', handleKeyDown);
        boardEl.addEventListener('touchstart', handleTouchStart, { passive: false });
        boardEl.addEventListener('touchend', handleTouchEnd);
    }
    function stop() {
        document.removeEventListener('keydown', handleKeyDown);
        boardEl.removeEventListener('touchstart', handleTouchStart);
        boardEl.removeEventListener('touchend', handleTouchEnd);
    }
    return { start, stop };
})());

// Flappy Bird
Object.assign(flappyBirdGame, (() => {
    const canvas = document.getElementById('flappy-bird-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('flappy-score');
    let animationFrameId;

    let bird, pipes, score, frame;
    const gravity = 0.5, lift = -10, pipeWidth = 80, pipeGap = 200;

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        bird = { x: 50, y: canvas.height / 2, size: 30, velocity: 0 };
        pipes = [];
        score = 0;
        frame = 0;
        scoreEl.textContent = 0;
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'yellow';
        ctx.fillRect(bird.x, bird.y, bird.size, bird.size);
        ctx.fillStyle = 'green';
        pipes.forEach(pipe => {
            ctx.fillRect(pipe.x, 0, pipeWidth, pipe.top);
            ctx.fillRect(pipe.x, canvas.height - pipe.bottom, pipeWidth, pipe.bottom);
        });
    }

    function update() {
        bird.velocity += gravity;
        bird.y += bird.velocity;

        if (frame % 90 === 0) {
            const top = Math.random() * (canvas.height - pipeGap - 100) + 50;
            pipes.push({ x: canvas.width, top: top, bottom: canvas.height - top - pipeGap, passed: false });
        }

        pipes.forEach((pipe, index) => {
            pipe.x -= 4;
            if (pipe.x + pipeWidth < 0) pipes.splice(index, 1);

            if (bird.x < pipe.x + pipeWidth && bird.x + bird.size > pipe.x &&
                (bird.y < pipe.top || bird.y + bird.size > canvas.height - pipe.bottom)) {
                stop();
                showAlertAndReturn("게임 오버!");
            }
            
            if (pipe.x + pipeWidth < bird.x && !pipe.passed) {
                pipe.passed = true;
                score++;
                scoreEl.textContent = score;
            }
        });

        if (bird.y + bird.size > canvas.height || bird.y < 0) {
            stop();
            showAlertAndReturn("게임 오버!");
        }
        frame++;
    }
    
    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }

    function jump() { bird.velocity = lift; }
    function handleKeyDown(e) { if (e.code === 'Space') jump(); }
    
    function start() {
        init();
        document.addEventListener('keydown', handleKeyDown);
        canvas.addEventListener('touchstart', jump);
        gameLoop();
    }
    function stop() {
        cancelAnimationFrame(animationFrameId);
        document.removeEventListener('keydown', handleKeyDown);
        canvas.removeEventListener('touchstart', jump);
    }
    return { start, stop };
})());

// Whack-a-Mole
Object.assign(whackAMoleGame, (() => {
    const canvas = document.getElementById('whack-a-mole-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('whack-score');
    const timeEl = document.getElementById('whack-time');
    let animationFrameId, timerInterval;

    let moles, score, timeLeft;
    const holeRadius = 40;
    const moleImg = new Image();
    moleImg.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cg%3E%3Cpath d='M50,75 C20,75 20,45 50,45 C80,45 80,75 50,75 Z' fill='%238D6E63'/%3E%3Cellipse cx='50' cy='45' rx='25' ry='20' fill='%23A1887F'/%3E%3Ccircle cx='38' cy='40' r='4' fill='black'/%3E%3Ccircle cx='62' cy='40' r='4' fill='black'/%3E%3Cellipse cx='50' cy='52' rx='6' ry='4' fill='%23D7CCC8'/%3E%3Cpath d='M45,52 C48,55 52,55 55,52' stroke='black' fill='none' stroke-width='1.5'/%3E%3C/g%3E%3C/svg%3E";

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        score = 0;
        timeLeft = 30;
        scoreEl.textContent = 0;
        timeEl.textContent = timeLeft;
        
        moles = [];
        const cols = Math.floor(canvas.width / (holeRadius * 2.5));
        const rows = Math.floor((canvas.height - 100) / (holeRadius * 2.5));
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                moles.push({
                    x: x * holeRadius * 2.5 + holeRadius * 1.25,
                    y: y * holeRadius * 2.5 + holeRadius * 1.25 + 50,
                    up: false,
                    timer: Math.random() * 2000 + 1000
                });
            }
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        moles.forEach(mole => {
            ctx.fillStyle = '#6D4C41';
            ctx.beginPath();
            ctx.arc(mole.x, mole.y, holeRadius, 0, Math.PI * 2);
            ctx.fill();
            if (mole.up) {
                const moleSize = holeRadius * 1.8;
                ctx.drawImage(moleImg, mole.x - moleSize / 2, mole.y - moleSize * 0.8, moleSize, moleSize);
            }
        });
    }

    function update(deltaTime) {
        moles.forEach(mole => {
            mole.timer -= deltaTime;
            if (mole.timer <= 0) {
                mole.up = !mole.up;
                mole.timer = Math.random() * (mole.up ? 1000 : 2000) + 500;
            }
        });
    }

    let lastTime = 0;
    function gameLoop(currentTime) {
        if (!lastTime) lastTime = currentTime;
        const deltaTime = currentTime - lastTime;
        lastTime = currentTime;
        
        update(deltaTime);
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function whack(e) {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;

        moles.forEach(mole => {
            if (mole.up && Math.hypot(x - mole.x, y - mole.y) < holeRadius) {
                mole.up = false;
                score++;
                scoreEl.textContent = score;
                mole.timer = 100; // Immediately hide
            }
        });
    }

    function start() {
        init();
        canvas.addEventListener('mousedown', whack);
        canvas.addEventListener('touchstart', whack);
        animationFrameId = requestAnimationFrame(gameLoop);
        timerInterval = setInterval(() => {
            timeLeft--;
            timeEl.textContent = timeLeft;
            if (timeLeft <= 0) {
                stop();
                showAlertAndReturn(`게임 종료! 최종 점수: ${score}`);
            }
        }, 1000);
    }
    function stop() {
        cancelAnimationFrame(animationFrameId);
        clearInterval(timerInterval);
        canvas.removeEventListener('mousedown', whack);
        canvas.removeEventListener('touchstart', whack);
    }
    return { start, stop };
})());

// Memory Game
Object.assign(memoryGame, (() => {
    const boardEl = document.getElementById('memory-board');
    const triesEl = document.getElementById('memory-tries');
    let cards, flippedCards, matchedPairs, tries;
    const EMOJIS = ['🐶', '🐱', '🐭', '🐹', '🐰', '🦊', '🐻', '🐼'];

    function init() {
        tries = 0;
        matchedPairs = 0;
        flippedCards = [];
        triesEl.textContent = 0;
        boardEl.innerHTML = '';
        
        cards = [...EMOJIS, ...EMOJIS]
            .sort(() => 0.5 - Math.random())
            .map((emoji, index) => ({ id: index, emoji: emoji, isFlipped: false, isMatched: false }));

        cards.forEach(card => {
            const cardEl = document.createElement('div');
            cardEl.className = 'memory-card';
            cardEl.dataset.id = card.id;
            cardEl.innerHTML = `
                <div class="card-face card-front"></div>
                <div class="card-face card-back">${card.emoji}</div>
            `;
            cardEl.addEventListener('click', () => flipCard(card, cardEl));
            boardEl.appendChild(cardEl);
        });
    }

    function flipCard(card, cardEl) {
        if (flippedCards.length === 2 || card.isFlipped || card.isMatched) return;
        
        card.isFlipped = true;
        cardEl.classList.add('is-flipped');
        flippedCards.push({ card, cardEl });

        if (flippedCards.length === 2) {
            tries++;
            triesEl.textContent = tries;
            checkForMatch();
        }
    }

    function checkForMatch() {
        const [first, second] = flippedCards;
        if (first.card.emoji === second.card.emoji) {
            first.card.isMatched = true;
            second.card.isMatched = true;
            first.cardEl.classList.add('is-matched');
            second.cardEl.classList.add('is-matched');
            matchedPairs++;
            flippedCards = [];
            if (matchedPairs === EMOJIS.length) {
                setTimeout(() => showAlertAndReturn(`성공! 시도 횟수: ${tries}`), 500);
            }
        } else {
            setTimeout(() => {
                first.card.isFlipped = false;
                second.card.isFlipped = false;
                first.cardEl.classList.remove('is-flipped');
                second.cardEl.classList.remove('is-flipped');
                flippedCards = [];
            }, 1000);
        }
    }

    function start() { init(); }
    function stop() { /* No ongoing processes to stop */ }
    return { start, stop };
})());

// Jump Game
Object.assign(jumpGame, (() => {
    const canvas = document.getElementById('jump-canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('jump-score');
    let animationFrameId;

    let player, platforms, score, cameraY, keys;
    const gravity = 0.4, jumpStrength = -13, playerSpeed = 7;

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        player = { x: canvas.width / 2 - 15, y: canvas.height - 50, width: 30, height: 30, dy: 0 };
        platforms = [{ x: canvas.width / 2 - 50, y: canvas.height - 20, width: 100 }];
        score = 0;
        cameraY = 0;
        scoreEl.textContent = 0;
        keys = { left: false, right: false };
        
        for (let i = 0; i < 20; i++) {
            platforms.push({
                x: Math.random() * (canvas.width - 100),
                y: platforms[platforms.length - 1].y - (60 + Math.random() * 60),
                width: 80 + Math.random() * 40
            });
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(0, -cameraY);
        
        ctx.fillStyle = 'lime';
        ctx.fillRect(player.x, player.y, player.width, player.height);
        
        ctx.fillStyle = '#8B4513';
        platforms.forEach(p => ctx.fillRect(p.x, p.y, p.width, 15));
        
        ctx.restore();
    }

    function update() {
        // Horizontal movement
        if (keys.left) player.x -= playerSpeed;
        if (keys.right) player.x += playerSpeed;
        
        // Screen wrap
        if (player.x > canvas.width) player.x = -player.width;
        if (player.x + player.width < 0) player.x = canvas.width;

        // Vertical movement
        player.dy += gravity;
        player.y += player.dy;

        // Camera follow
        const cameraThreshold = canvas.height / 2.5;
        if (player.y < cameraY + cameraThreshold) {
            cameraY = player.y - cameraThreshold;
        }

        // Collision with platforms (only when falling)
        if (player.dy > 0) {
            platforms.forEach(p => {
                if (player.x < p.x + p.width && player.x + player.width > p.x &&
                    player.y + player.height > p.y && player.y + player.height < p.y + 20) {
                    player.dy = jumpStrength;
                }
            });
        }

        // Game over
        if (player.y > cameraY + canvas.height) {
            stop();
            showAlertAndReturn("게임 오버!");
        }
        
        score = Math.max(score, Math.floor(-cameraY / 10));
        scoreEl.textContent = score;
        
        // Generate & remove platforms
        const highestPlatform = platforms[platforms.length - 1];
        if (highestPlatform.y > cameraY - 50) {
            platforms.push({
                x: Math.random() * (canvas.width - 100),
                y: highestPlatform.y - (60 + Math.random() * 60),
                width: 80 + Math.random() * 40
            });
        }
        if (platforms.length > 0 && platforms[0].y > cameraY + canvas.height + 50) {
            platforms.shift();
        }
    }

    function gameLoop() {
        update();
        draw();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    function handleKeyDown(e) {
        if (e.key === 'ArrowLeft') keys.left = true;
        if (e.key === 'ArrowRight') keys.right = true;
    }
    function handleKeyUp(e) {
        if (e.key === 'ArrowLeft') keys.left = false;
        if (e.key === 'ArrowRight') keys.right = false;
    }
    function handleTouchStart(e) {
        e.preventDefault();
        const touchX = e.touches[0].clientX;
        if (touchX < canvas.width / 2) keys.left = true;
        else keys.right = true;
    }
    function handleTouchEnd(e) {
        keys.left = false;
        keys.right = false;
    }
    
    function start() {
        init();
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);
        gameLoop();
    }
    function stop() {
        cancelAnimationFrame(animationFrameId);
        document.removeEventListener('keydown', handleKeyDown);
        document.removeEventListener('keyup', handleKeyUp);
        canvas.removeEventListener('touchstart', handleTouchStart);
        canvas.removeEventListener('touchend', handleTouchEnd);
    }
    return { start, stop };
})());

</script>
</body>
</html>
